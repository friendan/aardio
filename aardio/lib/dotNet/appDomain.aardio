//appDomain 应用程序域
namespace dotNet;

var freeDomainId = 0;

class appDomain{

	ctor( clr,domainName ){
		
		if (clr===null ){
			if(self.$singletonAppDomain){
				return self.$singletonAppDomain; 
			}
			
			if(!..dotNet.clr) error("请先导入 dotNet 或 dotNet.clr 库!",2);
			
			var clr,err = ..dotNet.clr();
			if(!clr){ return null,err; }
			
			return clr.createAppDomain();
		}
		elseif( domainName === null ) {
			if(!self.$singletonAppDomain) self.$singletonAppDomain = this;
		} 
		
		var appDomain;
		 
		if(!domainName) {
			domainName = "aardio.CLR.AppDomain["+ ..thread.getId() +"]" + freeDomainId;  
			freeDomainId++; 
		}
		
		if( __appDomainCache[domainName] ) return __appDomainCache[domainName];
		__appDomainCache[domainName] = this;
		
		this.clr = clr;
		var hr,pAppDomain = clr.corRuntimeHost.CreateDomainEx( ..string.toUtf16(domainName),clr.AppDomainSetup ); 
		
		var IsNetObject = ..com.IsNetObject
		this.wrapObject = function(obj,...){
			var t = IsNetObject(obj);
			if(t) return { _dotNetObject = obj; _dotNetAppDomain = this;@_objectMeta; }
			
			if( type(obj) == "function" ) {
				return function(...){
					return this.wrapObject(obj(...));
				}
			}
			return obj,...;
		};
	
		var wrapAssembly = function(asm,...){
			if(!asm) return asm,...;
			asm = unwrapObject(asm);
			 
			asm[["Name"]] = asm.GetName().Name;
			asm[["__createInstanceRaw"]] = asm.CreateInstance;
			asm[["__createInstanceTest"]] = function(typeObj,typeName,...){
				var arrlist = this.rawCreateArrayList({...}); 
				
				var ok,result  = call(this.utility.getInvokeMember2
									,this.utility,typeObj,asm ,typeName,""
									,512 /*BindingFlags.CreateInstance*/
									,arrlist,null); 
					 
				if( !ok ) return null,result;
				return this.wrapObject(result);
			} 
			asm[["new"]] = function(typeName,...){
				if( type(typeName)!=type.string )error("请指定类名称,参数@2",2);
				var obj,err = asm.__createInstanceTest(null,typeName,...);

				if(obj) return obj;
				if(!..string.startWith(typeName,asm.Name +".") && !(..string.indexOf(typeName,".")) )
					return asm.__createInstanceTest(null,asm.Name +"."+ typeName,...);
					
				return null,err;
			}
			asm[["createInstance"]] = asm[["new"]]; //@Deprecated

			asm[["invokeStaticMember"]] = function(typeName,...){
				var typeName,methodName = ..string.match(typeName,"(.+)\.([^.]+)$"); 
				
				var arrlist = this.rawCreateArrayList({...});
				
				var ok,result  = call(this.utility.getInvokeMember,this.utility, asm ,typeName,methodName
					,16 | 8 | 256 /*Public|Static|InvokeMethod*/
					,arrlist,null); 
				if( !ok ) return null,result;
				return this.wrapObject(result);
			}
			asm[["getStaticMember"]] = function(typeName,...){
				var typeName,methodName = ..string.match(typeName,"(.+)\.([^.]+)$");  
				var arrlist = this.rawCreateArrayList({...});
				
				var ok,result  = call(this.utility.getInvokeMember,this.utility, asm ,typeName,methodName
					,16 | 8 | 4096 | 1024 /*Public|Static|GetProperty|GetField*/
					,arrlist,null); 
				if( !ok ) return null,result;
				return this.wrapObject(result);
			} 
			asm[["_namespace"]] = {}
			asm[["appDomain"]] = this;
			  
			asm[["import"]] = function(typeName,...){
				if(type(typeName)=="table"){
					for(i=1;#typeName;1){ 
						asm[["import"]](typeName[i]);
					}
					return;
				}
				
				if(typeName===null) typeName = asm.Name;
				if( type(typeName)!=type.string )error("参数@1请指定类型名称",2);
				
				var generiTypeParams;
				if(...!==null){
					generiTypeParams = {...}; 
					
					typeName = typeName + "`"  + #generiTypeParams;
					
					//转换为 object 数组，避免转为字符串数组
					generiTypeParams = ..com.Variant(generiTypeParams,0xC/*_VT_VARIANT*/);
				}
				
				var nspace; 
				if(!generiTypeParams){
					nspace = asm[["_namespace"]][typeName];
					if( nspace ) return nspace;	
				}  
				 
				var objType;
				if(generiTypeParams){
					var ret = this.utility.GetGenericTypeByName(asm,typeName,generiTypeParams); 
					objType = unwrapObject(  ret ); 
					if(!objType) return null; 
				}
				else {
					objType = unwrapObject( this.utility.GetTypeByName(asm,typeName) );
				} 
				
				if(generiTypeParams){
					nspace = {_dotNetObject = objType}; 
				}
				else{
					nspace = ..table.namespace(..string.replace(typeName,"@+",".")); 
					if(!nspace) {
						error("Name conflict for namespace '"+typeName+"'",2);
					}
					elseif(nspace@) nspace = {_dotNetObject = objType};
					elseif(!nspace[["_dotNetObject"]]) {
						nspace[["_dotNetObject"]] = objType;
						nspace[["_dotNetAppDomain"]] = this;
					}
					
					asm[["_namespace"]][typeName] = nspace;
				}
				
				if(objType ? objType.IsEnum) {
					return this._createEnumMeta(nspace);
				}
				
				nspace@ = {
					
					_toComObject = lambda() owner[["_dotNetObject"]];
					_dotNetNamespace = typeName;
					_tostring = typeName;
					_eq = __equals;
					_set = function(k,v){
						if(objType && (!(v@[["_dotNetNamespace"]]))){ 
							var arrlist = this.rawCreateArrayList({v});
							var ok,result  = call(this.utility.getInvokeMember2,this.utility,objType,asm ,typeName,k
									,16 | 8 | 8192 | 2048 /*Public|Static|SetProperty|SetField*/
									,arrlist,null); 
									 
							if(!ok) error(result,2);
						}
						else {
							owner[[k]] = v;
						} 
					};
					_get = function(methodName,ownerCall){
						 
						if( type(typeName)!=type.string ) return owner[[methodName]]; 
						
						var tag = methodName[1]; 
						if(tag=='_'# ){
							if( (methodName=="_safearray" || methodName=="_type" || methodName=="_struct") ){
								return;
							}
							elseif(methodName == "__assembly__") {
								return asm;
							}  
						}
						elseif(tag=='$'# ) { 
							var k = methodName;
							var memberTypeName;
							var typeObj;
							
							if(k=="$"){
								memberTypeName = typeName;
								methodName = ..string.match(typeName,"[^\.\+]+$");
								typeObj = owner[["_dotNetParentClassObject"]];
							}
							else {
								methodName = ..string.right(methodName,-2);
								typeObj = owner[["_dotNetObject"]];
								
								if(!typeObj){
									memberTypeName = typeName + "." + methodName
								}
								else {
									memberTypeName = typeName + "+" + methodName;
								}
							}
							  
							owner[[k]] = function(...){
								
								var t = asm[["import"]](memberTypeName,...);  
								if(t) return t; 
								
								if(typeObj){
									var method = unwrapObject(
										 this.utility.getGenericMethod(typeObj
										,methodName,16 | 8 | 256 /*Public|Static|InvokeMethod*/
										,..com.Variant({...},0xC/*_VT_VARIANT*/) ,null) 
									);
										
									if(method){ 
										return function(...){
											var arrlist = this.rawCreateArrayList({...}); //存在可能参数@1为null,但其他参数不为 null
											
											return this.wrapObject(this.utility.callByMethodInfo(typeObj
												,method,16 | 8 | 256 /*Public|Static|InvokeMethod*/
												,arrlist,null))
										} ; 
									}
									
									error("没有找到泛型函数或泛型类",2);
								} 
								
								if(owner[[k]]){
									return owner[[k]];
								}
      
      							error("没有找到泛型类");
							}; 
							
							return owner[[k]];
						}
						
						 
						if(!ownerCall){ 
							
							var ok,result  = call(this.utility.getInvokeMember2,this.utility,objType,asm,typeName,methodName
								,16 | 8 | 4096 | 1024 /*Public|Static|GetProperty|GetField*/
								,null,null); 
							
							if( !ok ) {
								if(result){
									var ok,enumType = call(this.utility.getInvokeEnumType,this.utility,asm,typeName,methodName);
									if(ok && enumType) {
										owner[[methodName]] = this._createEnumMeta( {_dotNetObject = enumType} ); 
									} 
									else {
										if(!owner[["_dotNetObject"]]){
											if(methodName==="length") return null;//table.type 取 length 
											owner[[methodName]] = asm[["import"]](typeName + "." + methodName); 
										}
										else {
											memberType = unwrapObject( this.utility.GetTypeByName(asm,typeName + "+" + methodName) ); 
											if(memberType){//嵌套类
												owner[[methodName]] = asm[["import"]](typeName + "+" + methodName); 
												..com.Release(memberType);
												
												if(owner[[methodName]]){
													owner[[methodName]][["_dotNetParentClassObject"]] = owner[["_dotNetObject"]];
												}
											} 	
											else { 
												return ..table.getCall(owner,methodName);
											}
										}
									}
									
									return owner[[methodName]];
								}
								return null,result;	
							}
							return this.wrapObject(result);	
						}
						else {
							var memberType;
							if(!owner[["_dotNetObject"]]){
								memberType = unwrapObject( this.utility.GetTypeByName(asm,typeName + "." + methodName) ); 
							}
							else {
								memberType = unwrapObject( this.utility.GetTypeByName(asm,typeName + "+" + methodName) ); 
							}
							  
							if(memberType){	
								if(!owner[["_dotNetObject"]]){
									owner[[methodName]] = asm[["import"]](typeName + "." + methodName); 
								}
								else {
									owner[[methodName]] = asm[["import"]](typeName + "+" + methodName);
									
									if(owner[[methodName]]){
										owner[[methodName]][["_dotNetParentClassObject"]] = owner[["_dotNetObject"]];
									}
								}  
								
								..com.Release(memberType);
							} 
							else{
								owner[[methodName]] = function(...){
									var arrlist = this.rawCreateArrayList({...}); //存在可能参数@1为null,但其他参数不为 null
									var ok,result  = call(this.utility.getInvokeMember2,this.utility,objType, asm ,typeName,methodName
										,16 | 8 | 256 /*Public|Static|InvokeMethod*/
										,arrlist,null); 
									if( !ok ) error(result,2)
									return this.wrapObject(result);
								} 
							}
							 
							return owner[[methodName]];
						}
						
					};
					_call = function(...){ 
						var obj,err;
						var preCtor = owner[["ctor(...)"]];
						var args;
						
						if( !preCtor ){ 
							obj,err = asm.__createInstanceTest(owner[["_dotNetObject"]],typeName,...); 
						}
						else {
							obj,err = preCtor( function(...){ 
								return asm.__createInstanceTest(owner[["_dotNetObject"]],typeName,...)
							},...);
						}
						
						if(obj) {
							if(owner[["ctor"]]) owner[["ctor"]](obj);
							return obj;
						}
						
						if(err) error(err,2);
					}
				} 
				
				return nspace;
			} 
			
			return asm,...;
		}
		
		if(  (hr)>=0/*_SUCCEEDED*/ ){
			appDomain = ..com.QueryObject( pAppDomain);
			..com.Release(pAppDomain);
			
			this.loadFile  = function( rawAssembly,pdbData ){    
				if(type(rawAssembly)!=type.string )error("请指定程序集",2);
				
				if( #rawAssembly < 0x410/*_MAX_PATH_U8*/ ){
					if(!pdbData && ..io.exist(rawAssembly)) {
						return this.load(rawAssembly); 
					}
					
					rawAssembly = ..string.load(rawAssembly) : rawAssembly;
				}
				
				if( pdbData ){
					if(#pdbData < 0x410/*_MAX_PATH_U8*/ ){
						pdbData = ..string.load(pdbData) : pdbData;
					}
					
					return wrapAssembly( appDomain.Load_4(rawAssembly,pdbData) )
				}
				
				return wrapAssembly( appDomain.Load_3( rawAssembly ) );
			}; 
			
			this[["_assemblies"]] = {};
			this.load = function( name,data ){  
				if(!name) error("请指定程序集名称",2);  
				if(data) this.reference(name,data);
				
				var a = this[["_assemblies"]][name];
				if(a) return a;
				
				a = wrapAssembly( this.utility.loadAssembly( ..io.localpath(name) : name ) );
				if(a){
					this[["_assemblies"]][name] = a;
					return a;
				}
			};
			this.loadAppData = function(path,data){ 
				var path = ..io.appData(path,data); 
				if(path) return this.load(path);
			};
			this.import = function(nspace,path){
				var assembly = this.load(path:nspace);
				if(assembly) return assembly.import(nspace);
				else {
				 	error("加载程序集失败：" + (path:nspace));
				} 
			};
			 
			this.interop = this.loadFile($"~\lib\dotNet\.res\bin\Release\aardio.Interop.dll");  
			//this.interop = this.loadFile( "~\lib\dotNet\.res\bin\Debug\aardio.Interop.dll" ,"~\lib\dotNet\.res\bin\Debug\aardio.Interop.pdb" ); 
			
			//createInstance 要在构造函数完成后才能使用,这里必须用 __createInstanceRaw	 		
			this.utility = unwrapObject( this.interop.__createInstanceRaw("aardio.Interop.Utility") );  
		  	this.utility[["getInvokeMember"]] = this.utility.getInvokeMember;
		  	this.utility[["getInvokeMember2"]] = this.utility.getInvokeMember2;
		  	this.utility[["getInvokeObjectMember"]] = this.utility.getInvokeObjectMember;
			this.utility[["getInvokeEnumValue"]] = this.utility.getInvokeEnumValue; 
			this.utility[["getRoundTrip"]] = this.utility.getRoundTrip; 
			this.utility[["checkObjectMethod"]] = this.utility.getCheckObjectMethod;
			this.utility[["checkObjectMember"]] = this.utility.getCheckObjectMember;
			this.utility[["getGenericMethod"]] = this.utility.getGetGenericMethod;
			this.utility[["callByMethodInfo"]] = this.utility.getCallByMethodInfo; 
		 
			this.mscorlib = this.load("mscorlib");
			this.system = this.load("System");
			this.System = this.system.import("System");
			this.Array = this.mscorlib.import("System.Array");
			this.Drawing = this.import("System.Drawing");
			
			this.DispatchableDelegate = this.interop.import("aardio.Interop.DispatchableDelegate");
			//注意在此构造函数未退出前,如果调用下面还未创建的函数会出错
		}
		else {
			return null,..lasterr(hr,"dotNet.appDomain");
		}
		 
		this.id = appDomain.Id;
		this.appDomainReal = appDomain;
		this._dotNetObject = appDomain;
		this._dotNetAppDomain = this;
	};
	reference = function(path,data){
		if(!this.delegateAssemblyResolve){
			this[["(referencePaths)"]] = {};
			this[["(referenceAssemblies)"]] = {};
			
			var match = ..string.match;
			this.delegateAssemblyResolve = this.delegate.combine(
				this.appDomainReal,"AssemblyResolve",function(sender,args){
					var name = match(args.Name,"^[^,]+");
					var refs = this[["(referencePaths)"]];
					var path = refs[name];
					if(!path) return;
					
					var asm = this[["(referenceAssemblies)"]][name];
					if(asm){
						return asm;
					}
					
					if(type(path)=="function") {
						path = invoke(path,refs,name,args.Name,args);
						if(!type.isString(path)) {
							asm = path; 
							path = null;
						}
					} 
					
					if(path) asm = this.loadFile(path);
					this[["(referenceAssemblies)"]][name] = asm;
					return asm;
				} 
			)
		} 
			
		if(type(path)=="table"){
			..table.assign(this[["(referencePaths)"]],path);
		}
		else {
			this[["(referencePaths)"]][path] = data;
		} 
	};
	object = function(v,ref){
		if(v[["_dotNetObject"]] && !ref) return v;
		if(!IsNetObject(v) || ref)  v = this.utility.CreateAnyObject(v,ref);
		return { _dotNetObject = v; _dotNetAppDomain = this; @_objectMeta; 	} 
	};
	buffer = function(...){
    	return this.object(..raw.buffer(...),true);
    };
	byte = function(v,ref){
		return this.object(..com.byte(v),ref);	
	};
	ubyte = function(v,ref){
		return this.object(..com.ubyte(v),ref);	
	};
	word = function(v,ref){
		return this.object(..com.word(v),ref);	
	};
	uword = function(v,ref){
		return this.object(..com.uword(v),ref);	
	};
	int = function(v,ref){
		return this.object(..com.int(v),ref);	
	};
	uint = function(v,ref){
		return this.object(..com.uint(v),ref);	
	};
	long = function(v,ref){
		return this.object(..com.long(v),ref);	
	};
	ulong = function(v,ref){
		return this.object(..com.ulong(v),ref);	
	};
	float = function(v,ref){
		return this.object(..com.float(v),ref);	
	};	
	double = function(v,ref){
		return this.object(..com.double(v),ref);	
	}; 
	double = function(v,ref){
		return this.object(..com.double(v),ref);	
	}; 
	dict = function(tab,byRef){
		var kt,vt;
		for(k,v in tab){
			kt = type(k)=="string" ? this.System.String : k;
			vt = type(v)=="string" ? this.System.String : v;
			break;
		}
		
		if(kt && vt){
			var d = this.System.Collections.Generic.Dictionary.$(kt,vt)();
			for(k,v in tab){
				d.Add(k,v);
			} 
			
			if(byRef)return this.object(d,true);
			return d;
		};
	};
	createArray = function(t,...){
		if(...===null){
	
			if(t[[1]][["_dotNetObject"]]) {
				var arr = this.createArray(t[[1]].GetType(),#t);
				for(i=1;#t) arr[i] = t[[i]]; 
				return arr; 
			}
			
			return t;
		}
		
		return this.Array.CreateInstance(t,...);
	};
	rawCreateArrayList = function( tab ){ 
		var list = this.mscorlib.CreateInstance("System.Collections.ArrayList"); 
		if( tab ){
			var t,v;
			for(i=1;#tab){
				v = tab[i];
				t = type(v);
				if(t = "function" || t = "class" ) list.Add( this.safeCallback(v) );  
				elseif(t = "table" && #v && v[1][["_dotNetObject"]]) {
					var arr = this.createArray(v[1].GetType(),#v);
					for(i=1;#v;1) arr[i] = v[i]; 
					
					list.Add( arr );  
				}
				else list.Add(v); 
			} 
		}
		return list;
	}; 
	createArrayList = lambda(v) this.wrapObject( this.rawCreateArrayList(v) );
	createNameValueList = lambda(k,v) this.wrapObject( this.utility.NameValueList(k,v) );
	invokeMember = function(assemblyName,typeName,methodName,bindingFlags,target,...){
		var arrlist = this.rawCreateArrayList({...});
		var ok,result  = call(this.utility.getInvokeMember,this.utility, ..io.localpath(assemblyName) : assemblyName 
				,typeName,methodName ,bindingFlags : 0 ,arrlist,unwrapObject(target)); 
		if( !ok ) return null,result;
		
		if( result!==null ) return this.wrapObject(result);
	};
	checkInstanceMember = function(target,name,bindFlags){
		if(!bindFlags) bindFlags = 32 | 16 | 8 | 4 | 64 | 4096 | 1024 /*NonPublic|Public|Static|Instance|FlattenHierarchy|GetProperty|GetField*/
		var ok,result  = call(this.utility.checkObjectMember,this.utility,unwrapObject(target),name,bindFlags); 
		return ok && result; 
	};
	checkInstanceMethod = function(target,methodName){
		var ok,result  = call(this.utility.checkObjectMethod,this.utility,unwrapObject(target),methodName 
			,16 | 8 | 4 | 64| 256 /*Public|Static|Instance|InvokeMethod*/); 
		return ok && result; 
	};
	invokeInstanceMember = function(target,methodName,...){
		var arrlist = this.rawCreateArrayList({...});
		var ok,result  = call(this.utility.getInvokeObjectMember,this.utility,unwrapObject(target),methodName 
			,16 | 8 | 4 | 64| 256 /*Public|Static|Instance|InvokeMethod*/,arrlist); 
		if( !ok ) return null,result;
		
		if( result!==null ) return this.wrapObject(result);
	};
	setInstanceMember = function(target,methodName,...){
		var arrlist = this.rawCreateArrayList({...});
		var ok,result  = call(this.utility.getInvokeObjectMember,this.utility,unwrapObject(target),methodName 
			,16 | 8 | 4 | 64| 8192 | 2048 /*Public|Static|Instance|FlattenHierarchy|SetProperty|SetField*/ ,arrlist); 
		if( !ok ) return null,result;
		return true;
	};
	getInstanceMember = function(target,methodName,...){
		var arrlist = (...!=null) ? this.rawCreateArrayList({...}) : null;
		var ok,result  = call(this.utility.getInvokeObjectMember,this.utility,unwrapObject(target),methodName 
			,32 | 16 | 8 | 4 | 64 | 4096 | 1024 /*NonPublic|Public|Static|Instance|FlattenHierarchy|GetProperty|GetField*/ ,arrlist); 
		if( !ok ) return null,result;
		
		return this.wrapObject(result);
	};
	setItem = function(target,...){
		var arrlist = this.rawCreateArrayList({...});
		var ok,result  = call(this.utility.getInvokeObjectMember,this.utility,unwrapObject(target),"Item"  
			,16 | 4 | 8192 /*SetProperty*/ ,arrlist);
		if( !ok ) return null,result;
		return true;
	};
	getItem = function(target,...){
		var arrlist = this.rawCreateArrayList({...})
		var ok,result  = call(this.utility.getInvokeObjectMember,this.utility,unwrapObject(target),"Item" 
			,16 | 4 | 4096 /*GetProperty*/ ,arrlist);
		if( !ok ) return null,result;
		
		return this.wrapObject(result);
	};
	invokeStaticMember = function(assemblyName,typeName,...){
		var typeName,methodName = ..string.match(typeName,"(.+)\.([^.]+)$"); 
		
		var arrlist = this.rawCreateArrayList({...}); 
		var ok,result  = call(this.utility.getInvokeMember,this.utility, ..io.localpath(assemblyName) : assemblyName 
				,typeName,methodName ,16 | 8 | 256 /*Public|Static|InvokeMethod*/
				,arrlist,null); 
		if( !ok ) return null,result;
		
		if( result!==null ) return this.wrapObject(result);
	};
	getStaticMember = function(assemblyName,typeName,...){
		var typeName,methodName = ..string.match(typeName,"(.+)\.([^.]+)$"); 
			
		var arrlist = this.rawCreateArrayList({...}); 
		var ok,result  = call(this.utility.getInvokeMember,this.utility, ..io.localpath(assemblyName) : assemblyName 
				,typeName,methodName ,16 | 8 | 64 | 4096 | 1024 /*Public|Static|FlattenHierarchy|GetProperty|GetField*/
				,arrlist,null); 
		if( !ok ) return null,result;
		
		return this.wrapObject(result);
	}; 
	createInstance = function(assemblyName,typeName,...){
		if( !assemblyName ) error("请指定程序集,参数@1",2); 
		if(type(typeName)!=type.string )error("请指定类名称,参数@2",2);
		assemblyName = ..io.localpath(assemblyName) : assemblyName;
		
		if( ... !== null || (type(assemblyName)!="string"))  {
			var arrlist = this.rawCreateArrayList({...});
			var ok,result  = call(this.utility.getInvokeMember,this.utility, assemblyName 
					,typeName,"", 512 /*BindingFlags.CreateInstance*/
					,arrlist,null); 
					
			if( !ok ) return null,result;
			return this.wrapObject(result);
		}
		
		var handle;
		if(..io.exist(assemblyName)) handle = appDomain.CreateInstanceFrom(assemblyName,typeName);
		else handle = appDomain.CreateInstance(assemblyName,typeName);
		if(handle!==null) return this.wrapObject(handle.UnWrap());
	};
	createWebService = function(url,strNamespace,protocol,dllPath){
		var compiler = this.createCompiler("C#");
		if(dllPath){ 
			compiler.Parameters.OutputAssembly  =  ..io.fullpath(dllPath)
			compiler.Parameters.GenerateExecutable =  false;
			compiler.Parameters.GenerateInMemory =  false;
		}
		
		compiler.Parameters.CompilerOptions = "/optimize";
		var assembly = compiler.CompileWebService(url,strNamespace,protocol : "Soap");
		if(assembly) return wrapAssembly(assembly);
		return assembly,compiler.getLastError();
	}; 
	createCompiler = function(lang){ 
		
		var providers = {
			["C#"] = "Microsoft.CSharp.CSharpCodeProvider";
			["VB"] = "Microsoft.VisualBasic.VBCodeProvider";
		}
		var providerType = providers[lang];
		if( ! providerType ) error("请正确指定编译器语言",2)
		
		var compiler = this.utility.CreateCompiler(providerType); 
		if( compiler ){
			compiler[["_Reference"]] = compiler.getReference;
			compiler[["Reference"]] = function(path,...){
				if(path=="System"){
					path = "System.dll"; //默认已引用，避免冲突
				}
				
				path = ..io.localpath(path) : path; 
				var a = ::Kernel32.GetFileAttributes(path);
				if( (a!=-1) && ( a & 0x10/*_FILE_ATTRIBUTE_DIRECTORY*/) ){
					return owner._Reference( ..io.joinpath(path,...) );
				}
				
				if(!(..string.endWith(path,".dll",true) || ..io.exist(path) ) ){
					var location;
					var asms = appDomain.GetAssemblies();
					for(i,asm in asms){
						var name = ..string.match(asm.FullName,"^[^\s\,]+") 
						if( name  == path ){
							location = asm.Location;	
						}
					}
					
					if(!location){
						var asm = this.load(path);
						if(asm) location = asm.Location;
					}
					
					if(location){
						path = location;
					} 
				}
				
				var ret = owner._Reference( ..io.localpath(path) : path )
				if(!...) return ret;
				
				return owner.Reference(...);
			} 
			compiler[["_Compile"]] = compiler.getCompile;
			
			compiler[["loadcode"]] = ..string.loadcode;
			
			var loadcodeIfSourceIsString = function(){
				var code = compiler.Source; 
				if( type.isString(code)  ){
					if( !..string.find(code,'^<\xEF\xBB\xBF>?\\s*<\\?\\>>|<\\<\\?>') ){
						code = "?>" + code; 
					}
					
					var err;
					compiler.Source,err = compiler[["loadcode"]](code,compiler[["ownerArgs"]]);
					if(err) error(err,3); 
				}
			}
			
			compiler[["Compile"]] = function(dllPath,throwOnFailure){  
				
				if(dllPath){
					compiler.Parameters.OutputAssembly  =  ..io.fullpath(dllPath)
					compiler.Parameters.GenerateExecutable =  !..string.endWith(dllPath,".dll",true);
					compiler.Parameters.GenerateInMemory =  false;	
				}
				elseif(!compiler.Parameters.GenerateInMemory) {
					if(compiler.Parameters.OutputAssembly){
						compiler.Parameters.OutputAssembly = ..io.fullpath(compiler.Parameters.OutputAssembly)
					}
				}
				
				loadcodeIfSourceIsString(); 
				
				var src = compiler.Source;
				if(#compiler[["defaultSource"]]){
					if( type(compiler.Source)=="table" ){
						..table.unshift(compiler.Source,compiler[["defaultSource"]]); 
					}
					else {
						compiler.Source = compiler[["defaultSource"]] + '\r\n' + compiler.Source;
					} 
				}
				  
				var ret,err = wrapAssembly( owner._Compile() ); 
				compiler.Source = src;
				return ret,err;
			} 
			
			compiler[["defaultSource"]] = "";
			
			compiler[["CompileOrFail"]] = function(dllPath){
				var asm = owner.Compile(dllPath);
				if(!asm) error(compiler.getLastError(),2);
				return asm;
			}
		 
			compiler[["import"]] = function(path){
				var asm = owner.Compile(dllPath);
				if(!asm) error(compiler.getLastError(),2);
				return asm.import(path);
			}
			
			compiler[["addSource"]] = function(path,rep){
				var code = path;
				if(#path < 0x410/*_MAX_PATH_U8*/ && (..io.exist(path)||..io.localpath(path))){
					code = ..string.load(path);
				}
				
				if(!code) error("参数错误!",2);
			 
				if( ..string.find(code,'^<\xEF\xBB\xBF>?\\s*<\\?\\>>|<\\<\\?>') ){
					var err;
					code,err = compiler[["loadcode"]](code,compiler[["ownerArgs"]]); 
					if(err) error(err,2);
				}
				
				loadcodeIfSourceIsString(); 
				
				var src = compiler.Source;
				if(rep || !#src)  src = { code };
				elseif(type(src)=="table") ..table.push(src,code);	 
				else{
					loadcodeIfSourceIsString();  
					src = { compiler.Source,code }; 
				}
				
				compiler.Source = src;
			}
			
			
			compiler[["ownerArgs"]] = {};
			
		}
		return compiler;
	};
	_createEnumMeta = function(enumTable){
		var typeName = enumTable._dotNetObject.ToString();
	
		enumTable@ = {
			_toComObject = lambda() owner[["_dotNetObject"]]; 
			_topointer = lambda() owner[["_dotNetObject"]];
			_tostring = lambda() typeName;
			_eq = __equals;
			_get = function(name){
				if(type.isString(name)){ 
					owner[[name]] = this.utility.getInvokeEnumValue(owner._dotNetObject,name);
					return owner[[name]];
				}
			}; 
		}
		
		return enumTable; 
	};
	delegate = { 
		create = function(obj,name,func){ 
			return this.DispatchableDelegate.CreateDelegateByMemberName(obj,name,func);
		};
		combine = function(a,b,c){
			if(type(b)=="string"){ 
				if(!(a&&c)) return;
				return this.DispatchableDelegate.CombineDelegateByMemberName(a,b,c); 
			}
			else if(!(a && b)) return a || b;
			
			return this.DispatchableDelegate.CombineDelegates(a,b);
		};
		remove = function(a,b,c){ 
			if(type(b)=="string"){
				if(!(a&&c)) return;
				return this.DispatchableDelegate.RemoveDelegateByMemberName(a,b,c);
			}
			
			if(a&&b)return this.DispatchableDelegate.RemoveDelegate(a,b);
		};
		list = function(v){
			return v.GetInvocationList();
		};
	};
	safeCallback = function(cb){
		return function(...){
			var args,t = {...}
			for(i,a in args){
				t = IsNetObject(a);
				if(t) args[i] =  { _dotNetObject = a; _dotNetAppDomain = this;@_objectMeta; }  
			}
			
			return invoke(cb,owner,..table.unpackArgs(args));
		} 	
	};
	each = function(obj){ 
		var n = obj[["_dotNetObject"]] : obj;
		if(!..com.IsObject(n)){
			return ..table.eachIndex(obj);
		}
		
		if(obj[["_dotNetObject"]]){
			var enum;
			try{
				enum = obj.GetEnumerator();	
			} 
			
			if(enum){
				var i = 0;
				return function(){  
					i++;
					if(enum.MoveNext())return i,enum.Current;
				} 
			}			
		} 
		
		var next = ..com.each(n);   
		var is = ..com.IsNetObject;
		return function(){ 
			var i,v = next(); 
			if(is(v)) v = this.wrapObject(v); 
			return i,v;
		} 
	};
	unload = function(){
		if(appDomain){
			if(self.$singletonAppDomain ===  this){
				return;
			}
			
			__appDomainCache[domainName] = null;
			
			var pAppDomain = ..com.GetPointer(appDomain);
			var hr = clr.corRuntimeHost.UnloadDomain(pAppDomain)
			..com.Release(pAppDomain)
			
			appDomain = null;
			this.appDomainReal = null;
			
			if(  (hr)>=0/*_SUCCEEDED*/ ) return true;
			return null,..lasterr(hr);
		}
	};
	@_meta;
}

namespace appDomain{

	__appDomainCache = {} 
	__equals = function(v) {
		var nObj = owner[["_dotNetObject"]] 
		if(nObj){
			if (nObj === v[["_dotNetObject"]])  return true; 
			var obj,err = owner._dotNetAppDomain.invokeInstanceMember(nObj,"Equals",v);
			if(!err) return obj;
		}
		
		return false;
	}
	
	_meta = {
		_toComObject = lambda() owner[["_dotNetObject"]];
		_topointer = lambda() owner[["_dotNetObject"]];
		_tostring = lambda() owner[["_dotNetObject"]].ToString();
		_eq = __equals;
	}
	
	var __reservedProperties = {_struct=1;Item=1;setItem=1;getItem=1;byRef=1}
	_objectMeta = {
		
		_get = function(k,ownerCall){
			var object = owner[["_dotNetObject"]];
			var appDomain = owner._dotNetAppDomain;
			
			if(ownerCall===null/*下标（索引）操作符*/){
				if(type(k)==="number"){
					var obj,err = appDomain.wrapObject( appDomain.getItem(object,k-1) );
					if(err && obj===null) error(err,2);
					return obj;
		 		} 
		 		
		 		var obj,err = appDomain.wrapObject( appDomain.getItem(object,k) ); 
		 		if(err && obj===null ){
		 			if(appDomain.checkInstanceMember(object,"Item",16 | 4 | 4096 /*Public|Instance| |GetProperty */)){
		 				error(err,2);
		 			}
		 		}
		 		else {
		 			return obj;
		 		}
			}
		 	elseif(__reservedProperties[k]){
		 		if(k=="Item") {
					owner[["Item"]] = { _dotNetObject = object; _dotNetAppDomain = appDomain;@_objectItemMeta; }
					return owner[["Item"]];
				}
				elseif(k=="getItem") {
					owner[["getItem"]] = function(k,...) {
						var obj,err = appDomain.wrapObject( appDomain.getItem(object,k,...) ); 
						if(obj===null && err) error(err,2);
						return obj;
					}
					return owner[["getItem"]];
				}
				elseif(k=="setItem") {
					owner[["setItem"]] = function(k,...){ 
						var ok,err = appDomain.setItem(object,k,...) 
						if(!ok && err) error(err,2);
					} 
					return owner[["setItem"]];
				}
				elseif(k=="byRef" && ownerCall) {
					if( ..com.IsNetObject(object) === 2 ) {
						return function(r){
							if(r===null) return object.ByRef;
							object.ByRef = r;
							return owner;
						}  
					}
				}
				elseif(k=="_struct") return;		
		 	}
		 	
		 		
		 	if(k[1]=='$'#){
		 		var methodName = ..string.right(k,-2);
		 	 
		 	 	owner[[k]] =  function(...){ 
		 	 		var method = unwrapObject( appDomain.utility.getGenericMethod(null
						,methodName,16 | 8 | 4 | 64| 256 /*Public|Static|Instance|InvokeMethod*/
						,..com.Variant({...},0xC/*_VT_VARIANT*/),object )
					);
					 
					if(method){
						return function(...){
							var arrlist = appDomain.rawCreateArrayList({...}); //存在可能参数@1为null,但其他参数不为 null
							
							return appDomain.wrapObject(appDomain.utility.callByMethodInfo(null
								,method,16 | 8 | 4 | 64| 256 /*Public|Static|Instance|InvokeMethod*/
								,arrlist,object))
						} ; 
					}	
					
					error("没有找到泛型函数或泛型类",2);
		 	 	}
		 	 	
				return owner[[k]] ; 
			}  
		 	
			if(ownerCall){
				owner[[k]] = function(...){
					var obj,err = appDomain.invokeInstanceMember(object,k,...);
					if( err && (obj==null)  ) error(err,2) 
					return obj; 
				}
				return owner[[k]];
			}
			var obj,err = appDomain.wrapObject( appDomain.getInstanceMember(object,k) );
			if(err && obj === null){
				if(appDomain.checkInstanceMethod(object,k)){
					owner[[k]] = function(...){
						var obj,err = appDomain.invokeInstanceMember(object,k,...);
						if( err &&  (obj==null) ) error(err,2) 
						return obj; 
					}
					return owner[[k]];	
				} 
			}
			return obj;
		};
		_set = function(k,v,ownerAttr){
			var app = owner._dotNetAppDomain;
			var object = owner[["_dotNetObject"]];

			if(!ownerAttr){
				if(type(k)==="number"){
					var ok,err = app.setItem(owner[["_dotNetObject"]],k-1,v);
					if(!ok && err) error(err,2);
					return;
		 		} 
		 		
		 		var ok,err = app.setItem(owner[["_dotNetObject"]],k,v);
		 		if(!ok && err) {
		 			if(app.checkInstanceMember(object,"Item",16 | 4 | 8192 /*Public|Instance| |SetProperty */)){
		 				error(err,2);
		 			}
		 		} 
		 		else {
		 			return;
		 		}
		 		
			}
			
			var ok,err = app.setInstanceMember(object,k,v);
			if(!ok && err) error(err,2);
		};
		_toComObject = lambda() owner[["_dotNetObject"]];
		_topointer = lambda() owner[["_dotNetObject"]];
		_json = function(pretty){
			var app = owner._dotNetAppDomain;
			if(app.jsonStringify){return app.jsonStringify(owner,pretty),true}
			return owner.ToString(); 
		};
		_tostring = function(...){
			return owner.ToString(...);
		};
		_tonumber = function(){
			return tonumber(owner.ToString());
		};
		_call = function(...){
			return owner.Invoke(...);
		};
		_eq = __equals;
		
		//以下操作符不支持 .NET 基础值类型 
		_lt = lambda(b) owner.op_LessThan(owner,b);
		_le = lambda(b) owner.op_LessThanOrEqual(owner,b); 
		_add = lambda(b) owner.op_Addition(owner,b);
		_sub = lambda(b) owner.op_Subtraction(owner,b); 
		_mul = lambda(b) owner.op_Multiply(owner,b); 
		_div = lambda(b) owner.op_Division(owner,b);  
		_mod = lambda(b) owner.op_Modulus(owner,b);  
		_unm = lambda(b) owner.op_UnaryNegation(owner,b); 
		_lshift = lambda(b) owner.op_LeftShift(owner,b);  
		_rshift = lambda(b) owner.op_RightShift(owner,b); 
		_pow = lambda(b) owner.Pow(owner,b); 
	} 
	
	_objectItemMeta = {
		_get = function(k){
		 	if(k=="_struct") return;
			var appDomain = owner._dotNetAppDomain;
			 
			var obj,err = appDomain.wrapObject( appDomain.getItem(owner[["_dotNetObject"]],k) );
			if(obj===null && err){
				error(err,2);
			}
			return obj;
		};
		_set = function(k,v){
			var ok,err = owner._dotNetAppDomain.setItem(owner[["_dotNetObject"]],k,v);
			if(!ok && err) error(err,2); 
		};
		_toComObject = lambda() owner[["_dotNetObject"]];
		_topointer = function(){
			return owner[["_dotNetObject"]];
		};
		_json = function(pretty){
			var app = owner._dotNetAppDomain;
			if(app.jsonStringify){return app.jsonStringify(owner,pretty),true}
			return owner; 
		};
		_tostring = function(...){
			return owner._dotNetAppDomain.invokeInstanceMember(owner[["_dotNetObject"]],"ToString",...);
		};
		_call = function(...){
			var appDomain = owner._dotNetAppDomain;
			var obj,err = appDomain.wrapObject( appDomain.getItem(owner[["_dotNetObject"]],...) );
			if(obj===null && err){
				error(err,2);
			}
			return obj;
		};
		_eq = __equals;
		
		//以下操作符不支持 .NET 基础值类型 
		_lt = lambda(b) owner.op_LessThan(owner,b);
		_le = lambda(b) owner.op_LessThanOrEqual(owner,b); 
		_add = lambda(b) owner.op_Addition(owner,b);
		_sub = lambda(b) owner.op_Subtraction(owner,b); 
		_mul = lambda(b) owner.op_Multiply(owner,b); 
		_div = lambda(b) owner.op_Division(owner,b);  
		_mod = lambda(b) owner.op_Modulus(owner,b);   
		_unm = lambda(b) owner.op_UnaryNegation(owner,b); 
		_lshift = lambda(b) owner.op_LeftShift(owner,b);  
		_rshift = lambda(b) owner.op_RightShift(owner,b); 
		_pow = lambda(b) owner.Pow(owner,b); 
	} 

	unwrapObject = function(obj){
		return obj[["_dotNetObject"]] ||obj;
	}
	
	..subscribe("beforeUnload",function(){
		self.$singletonAppDomain = null;
		for(k,appDomain in __appDomainCache){
			appDomain.unload(); 
		}	
	} );
 	
 	var reopenConsole = function(){
 
 		for(k,appDomain in __appDomainCache){
			appDomain.utility.ReopenConsole(!!..io.utf8); 
		}
 	}
 	if(::Kernel32.GetConsoleWindow()) reopenConsole();
 	..subscribe("afterConsoleOpen",reopenConsole);
}

/**intellisense()
dotNet.appDomain( = 创建应用程序域,\n注意应当通过导入 dotNet 库自动导入 dotNet.appDomain
dotNet.appDomain(.() = 不指定参数为当前线程创建唯一的应用程序域实例,\n该实例可能被其他代码使用,主动调用 unload 函数会被忽略,\n线程结束前会自动释放此实例。\n\n成功返回应用程序域,失败返回 null,错误信息,\n失败一般是因为系统没有安装 .NET 运行时。\n除了XP系统，WIN7 以及 WIN7 以上系统已自带 .NET 运行时,\n所以不检测返回值也行。\n\n注意应当通过导入 dotNet 库自动导入 dotNet.appDomain
dotNet.appDomain(.(clr,domainName) = 参数 @clr 指定 dotNet.clr 对象，\n可选用 @domainName 指定应用程序域名称，\n指定参数时应改用 dotNet.clr 对象的 createAppDomain 函数\n\n无参数调用 dotNet.appDomain 总是返回默认单例应用程序域，\n引入 dotNet 库也会自动创建默认应用程序域 
dotNet.appDomain() = !dotNetAppDomain.
end intellisense**/

/**intellisense(!dotNetAppDomain)
id = 应用程序域 ID\
clr = .NET 运行时\n!dotNetClr.
appDomainReal = AppDomain 托管对象
interop = aardio.Interop.dll 程序集\n!dotNetCrlAssembly.
utility = aardio.Interop.Utility 对象
invokeMember(.(程序集,"类名","方法名",BindingFlags,目标对象,其他调用参数) = 调用类方法,目标对象可省略,\n失败返回空值,以及错误信息
invokeStaticMember(.(程序集,"类型名->方法名",其他调用参数) = 参数一可以是程序集对象,名称或路径都可以,\n调用类的静态方法,支持传入多个调用参数并返回值。	\n失败返回空值,以及错误信息		
getStaticMember(.(程序集,"类型名->字段名") = 参数一可以是程序集对象,名称或路径都可以,\n获取静态字段、属性值、枚举值等。
createInstance(.(程序集,"类名",其他调用参数) = 参数一可以是程序集对象,名称或路径都可以,\n调用类的构造函数,支持传入多个调用参数并返回创建的对象。	\n失败返回空值,以及错误信息		
invokeInstanceMember(.(目标对象,"方法名",其他调用参数) = 调用类的成员方法,支持传入多个调用参数并返回值	\n失败返回空值,以及错误信息	
getInstanceMember(.(目标对象,"字段名") = 获取对象字段或属性\n失败返回空值,以及错误信息	
setInstanceMember(.(目标对象,"字段名",值) = 设置对象实例的字段或属性\n成功返回 true ,失败返回空值,以及错误信息
load( = 使用当前线程默认应用程序域载入并返回程序集（DLL）。\n在当前应用程序域如果已使用此函数导入同名程序集，\n则直接返回该程序集
load(.("程序集名") = 使用当前线程默认应用程序域载入并返回程序集。\n参数可以是程序集（DLL）名称或路径。\n\n此函数会按以下顺序调用 .NET 函数尝试加载程序集：\n└── Assembly.LoadWithPartialName\n└── Assembly.Load\n└── Assembly.LoadFrom\n└── Assembly.LoadFile
load(.("程序集名",虚拟程序集数据或路径) = 首先在『虚拟程序集引用表』中注册程序集名，\n参数 @2 指定对应的内存 DLL 数据或 DLL 路径（支持 EXE 内嵌资源）。\n然后再调用 load 函数加载并返回该虚拟程序集
loadFile( = 使用当前线程默认应用程序域载入程序集（DLL）。\n参数可以是 DLL 路径，内存 DLL，或 EXE 内嵌资源。\n此函数并不支持 『虚拟程序集引用表』，无法在内存添加依赖 DLL\n程序集如果引用了自身路径必须改用 load 函数加载
loadFile(.("程序集路径") = 使用当前线程默认应用程序域载入程序集,\n参数可以是 DLL 路径，内存 DLL，或 EXE 内嵌资源。\n\n在路径字符串前加$符号可将文件编译并嵌入 aardio 代码,\n可选在第2个参数中指定pdb调试数据或pdb调试文件路径
import( = 加载程序集，导入 .NET 名字空间、类、枚举。\n在当前应用程序域 import,load 等函数不会导入重复的程序集，\n同一程序集中不会重复导入相同的名字空间。 \n\n如果已存在同名的全局名字空间但元表为空（并未导入 .NET 名字空间），\n则导入 .NET 名字空间到已存在的名字空间。\n\n如果已存在同名的全局名字空间但元表非空（通常为已导入的  .NET 名字空间 ），\n则不会覆盖已存在的名字间，而是在返回值返回当前调用实际创建的名字空间。\n加载程序集或依赖程序集失败时此函数会抛出异常。
import(.(名字空间) = 加载参数 @1 指定文件名的程序集，并导入同名的 .NET 名字空间或类。\n当程序集文件名与导入名字相同时，可以省略 指定程序集名称的参数 @2。\n\n返回名字空间可作为类构造函数调用并创建对象。\n也可以用成员操作符获取静态成员，或调用静态函数。\n\n导入的 .NET 名字空间在正常访问其成员时会触发元方法以获取并创建下级名字空间、类、枚举等。\n但导入名字空间的函数（以及 namespace 语句）创建的上级名字空间并不会主动导入同名 .NET 名字空间\。\n\n此函数会尽可能重用已存在的 aardio 全局名字空间导入 .NET 名字空间。\n如果该全局名字空间已导入其他 .NET 名字空间则不会覆盖已存在的名空间。\n此函数总是会返回当前调用实际创建的名字空间。
import(.(名字空间,程序集名) = 加载参数@2指定文件名字的程序集。\n将 参数@1 指定的空间、类、枚举等导入 aardio 全局名字空间。\n必须指定完整名字空间。\n参数 @1 可指定名字空间也可以指定要导入的名字空间数组。\n\n在当前应用程序域 import,load 等函数不会导入重复的程序集，\n同一程序集中不会重复导入相同的名字空间。 \n\n返回名字空间可作为类构造函数调用并创建对象。\n也可以用成员操作符返回静态成员，或调用静态函数。\n\n导入的 .NET 名字空间在正常访问其成员时会触发元方法以获取并创建下级名字空间、类、枚举等。\n但导入名字空间的函数（以及 namespace 语句）创建的上级名字空间并不会主动导入同名 .NET 名字空间。\n\n此函数会尽可能重用已存在的 aardio 全局名字空间导入 .NET 名字空间。\n如果该全局名字空间已导入其他 .NET 名字空间则不会覆盖已存在的名空间。\n此函数总是会返回当前调用实际创建的名字空间
import() = !dotNetNameSpace.
load() = !dotNetCrlAssembly.
loadFile() = !dotNetCrlAssembly.
loadAppData( = 可用于嵌入并自 %appData% 目录加载\n不支持通过 loadFile 函数内存加载的程序集
loadAppData(.(path,data) = 用 @path 指定 %appData% 目录下的相对路径,\n将 @data 参数指定的内存程序集数据释放到该路径,\n并使用 load 函数加载此程序集,\n@data 参数应在路径前加$符号使文件数据嵌入到代码中
loadAppData() = !dotNetCrlAssembly.
unload() = 卸载应用程序域,一般不需要手动调用此函数,\n当前线程退出时会自动释放此线程创建的所有应用程序域,\n不带参数调用 dotNet.appDomain 创建的应用程序域不应手动调用此函数释放
createWebService( = 创建 Web 服务程序集
createWebService(.(服务网址,名字空间,协议名,DLL路径) = 创建 Web 服务程序集,可选在参数@2中指定一个自定义的名字空间\n协议名默认为"Soap",可选值"Soap12",\n如果使用参数@4指定输出DLL路径则在内存中编译程序集
createWebService() = !dotNetCrlAssembly.
createCompiler("C#") = 创建C#编译器
createCompiler("VB") = 创建VB编译器
createCompiler() = !dotNetCompiler.
createArray( = 创建 .NET 类型化数组。\n.NET 通常要求数组类型完全匹配，可以用这个函数创建类型匹配的数组。\n\n包含.NET 对象的普通 aardio 数组在传入 .NET 时也会临时转换为类型化数组\n默认的普通数值数组传入 .NET 为 double 数组，但支持自适应转换类型。\n也可以用 dotNet.double,dotNet.int 等函数创建类型化数值数组。\n\n注意 .NET 数组对象应当用 Length 属性取数组长度而非用 #号取长度，\n.NET 中的简单值类型数组在 aardio 中会转换为 com.SafeArray 数组，\ncom.SafeArray 数组可以用 # 取长度
createArray(.(类型,长度->->->) = 参数 @1 请指定 .NET 类型，\n类型通常由 dotNet.import 导入，或用 .NET 对象的 GetType 函数获取。\n至少指定一个数组长度参数，可指定多个长度参数以创建多维数组
createArray(.(数组) = 参数 @1 请指定数组。\n包含.NET 对象的普通数组返回为 .NET 类型化数组，\n传入其他任何类型参数直接返回
createArrayList(.(初始化数组) = 创建 System.Collections.ArrayList 对象\n可传递到C#函数中,C#中应声明为 object 类型,然后强制转换为 ArrayList,\n可选参数一指定 table 数组用于初始化对象
createArrayList() = !dotNetCrlArrayList.
createNameValueList(.(names,values) = 创建 List<NameValue<K,V>> 列表对象,\n参数@name,@value 必须是长度相等的非空数组,\n返回 List 对象的每个元素都具有 Name,Value 属性，\n其值由 @names,@values 参数按数组索引顺序分配
delegate = 用于操作 .NET 委托（Delegate）或事件（event），\n在 .NET 里函数要转换为委托对象才能作为回调函数传输，\n在 aardio 里对所有 .NET 对象的委托字段直接赋值总是覆盖而不是追加，\n对所有 .NET 事件赋值时总是追加而不是覆盖，\n!dotNetDelegate.
reference( = 在『虚拟程序集引用表』注册一个或多个虚拟程序集，\n这些虚拟程序集可以是内存程序集、本地程序集、EXE 内嵌资源中的程序集。\n\naardio 加载的 .NET 程序找不到程序集（DLL）时，\n会查找『虚拟程序集引用表』并加载已注册的虚拟 DLL
reference(.(simpleAssemblyName,pathOrData) = 在『虚拟程序集引用表』注册虚拟程序集（DLL）。\n@simpleAssemblyName 指定程序集短名称（虚拟 DLL 文件名）\n@pathOrData 指定程序集路径或内存数据，支持内嵌资源路径\n@pathOrData 也可以是返回程序集路径或数据的回调函数
reference(.(assemblyName2pathOrData) = 在『虚拟程序集引用表』注册多个虚拟程序集（DLL）。\n@assemblyName2pathOrData 指定一个表：\n表的「键」为虚拟程序集短名称（ DLL 文件名 ），\n\n键对应的「值」指定程序集内存数据或程序集路径（支持内嵌资源）
wrapObject(__) = 如参数是原生 .NET 对象,则返回 dotNet.object 对象，否则直接返回参数。\n\n所有 .NET 原生对象已经自动转换为 dotNet.object 对象，\n除非 .NET 调用普通 aardio 对象的成员函数而非回调特定的委托或事件函数。\n这时候回调参数中的 .NET 对象需要用此函数转换，但数值和字符串不需要转换。\n\n参数传入 com.IsNetObject 函数会返回非 0 值即为原生 .NET 对象，\n非原生 .NET 对象转换为 dotNet.object 应当直接调用 dotNet.object 函数。
object( = 转换参数 @1 指定的 aardio 值或数组为 .NET 原生 DispatchableObject 对象，\n并返回为 aardio 可操作的 dotNet.object 对象。\n\n也可用于转换 原生 .NET 对象为 dotNet.object ，\n或转换 dotNet.object 为支持引用 dotNet.object。\n\ndotNet.object 如果存储的是 Primitive,enum,string 类型或这些类型的数组，\n则可以使用 Value 属性读写值。\n\ndotnet.object 对象支持用 tostring 转换为字符串，\n如果存储的是数值则支持调用 tonumber 函数转为普通数值。
object(.(value,byRef) = 参数 @byRef 为 true 则支持 .NET 的输出或引用参数\n\n参数 @value 如果指定纯 aardio 对象或数组。\n则转换为 .NET 原生 DispatchableObject 对象，并封装为 dotNet.object 后返回。\n\n如果参数 @1 指定 dotNet.object 对象且参数 @2 不为 true 则直接返回。\n如果参数传入原生 .NET 对象且参数 @2 不为 true 则仅转换为 dotNet.object。\n如果参数 @2 为 true，则这些对象都会转换为 DispatchableObject 并返回新的 dotNet.object
buffer(.(初始值) = 分配可读写的、固定长度的字节数组。\n参数可以是一个结构体、字符串、或 buffer,传入{ }返回null,\n重新分配内存并复制初始值指定的数据。\n返回封包 buffer 的 dotNet.object 对象
buffer(.(长度,初始值) = 分配可读写的、固定长度的字节数组。\n\n参数一指定需要分配的内存大小,\n,内存初始值可以用结构体、指针、buffer、或字符串指定一段内存数据,\n也可用一个数值指定所有字节的初始值,不指定默认初始化所有字节为0,\n\n如果初始值指定为字符串或buffer类型，\n填充初始数据以后剩余的字节会全部初始为为0\n返回封包 buffer 的 dotNet.object 对象
byte( = 创建 .NET System.SByte 类型数值或数组
byte(.(value,byRef) = 创建 .NET System.SByte 类型数值或数组，\n用于存储8位整数。\n\n参数 @value 可以为数值或数组，\n参数 @byRef 为 true 则支持 .NET 的输出或引用参数
ubyte( = 创建 .NET System.Byte 类型数值或数组
ubyte(.(value,byRef) = 创建 .NET System.Byte 类型数值或数组，\n用于存储8位无符号整数。\n\n参数 @value 可以为数值或数组，\n参数 @byRef 为 true 则支持 .NET 的输出或引用参数
word( = 创建 .NET System.Int16 类型数值或数组
word(.(value,byRef) = 创建 .NET System.Int16 类型数值或数组，\n用于存储16位整数。\n\n参数 @value 可以为数值或数组，\n参数 @byRef 为 true 则支持 .NET 的输出或引用参数
uword( = 创建 .NET System.UInt16 类型数值或数组
uword(.(value,byRef) = 创建 .NET System.UInt16 类型数值或数组，\n用于存储16位无符号整数。\n\n参数 @value 可以为数值或数组，\n参数 @byRef 为 true 则支持 .NET 的输出或引用参数
int( = 创建 .NET System.Int32 类型数值或数组
int(.(value,byRef) = 创建 .NET System.Int32 类型数值或数组，\n用于存储32位整数。\n\n参数 @value 可以为数值或数组，\n参数 @byRef 为 true 则支持 .NET 的输出或引用参数,\n\n注意普通数值传入 .NET 函数时，\n整数默认转为32位整数,小数默认按double类型处理
uint( = 创建 .NET System.UInt32 类型数值或数组
uint(.(value,byRef) = 创建 .NET System.UInt32 类型数值或数组，\n用于存储32位无符号整数。\n\n参数 @value 可以为数值或数组，\n参数 @byRef 为 true 则支持 .NET 的输出或引用参数
long( = 创建 .NET System.Int64 类型数值或数组
long(.(value,byRef) = 创建 .NET System.Int64 类型数值或数组，\n用于存储64位整数。\n\n参数 @value 可以为数值或数组，\n参数 @byRef 为 true 则支持 .NET 的输出或引用参数
ulong( = 创建 .NET System.UInt64 类型数值或数组
ulong(.(value,byRef) = 创建 .NET System.UInt64 类型数值或数组，\n用于存储64位无符号整数。\n\n参数 @value 可以为数值或数组，\n参数 @byRef 为 true 则支持 .NET 的输出或引用参数
float( = 创建 .NET System.Single 类型数值或数组
float(.(value,byRef) = 创建 .NET System.Single 类型数值或数组，\n用于存储32位浮点数。\n\n参数 @value 可以为数值或数组，\n参数 @byRef 为 true 则支持 .NET 的输出或引用参数
double( = 创建 .NET System.Double 类型数值或数组
double(.(value,byRef) = 创建 .NET System.Double 类型数值或数组，\n用于存储64位浮点数。\n\n参数 @value 可以为数值或数组，\n参数 @byRef 为 true 则支持 .NET 的输出或引用参数,\n\n注意普通数值传入 .NET 函数时，\n整数默认转为32位整数,小数默认按double类型处理
each(netObj) = @for i,v in ??.each(__/*输入需要遍历的 .NET 对象或普通数组，\n返回值 i 为当前索引,v 为当前值，\n注意并非所有 .NET 类型都支持此接口*/) {
	
}
Drawing = System.Drawing
Array = System.Array
dict( = 将非空表转换为 .NET 字典。\n如果要创建空字典，调用返回对象的 Clear 函数清空即可。\n返回对象支持用下标操作符访问键值对。\n可用 dotNet.each 遍历字典。
dict(.(tab,byRef) = 将非空表转换为 .NET 字典（Dictionary）对象。\n\n如果传入空表或 null 返回 null 值。\n否则必须传入非空表，表中所有的键必须是相同类型。\n表中所有的值必须是相同类型。\n\n参数 @byRef 为可选参数，如果 @byRef 为 true，\n则返回对象可作为 .NET 输出与引用参数使用
dict() = !stdNetDictionary.
end intellisense**/

/*****intellisense(!stdNetDictionary)
Add(.(key,value) = 添加键值
Clear() = 清空字典
ContainsKey(.(key) = 是否包含参数 @key 指定键的值
ContainsValue(.(value) = 是否包含参数 @value 指定值的键
Remove(.(key) = 移除参数 @key 指定的键值
Count = 包含键值对总数
end intellisense*****/

/**intellisense(!dotNetCrlArrayList) 
Add(.(添加对象) = 添加成员到数组中
Clear() = 添空数组
ToArray() = 转换并返回数组
ToList() = 转换并返回 List 对象
end intellisense**/

/****intellisense(!dotNetCompiler)
Parameters = 编译参数
Parameters.OutputAssembly  = 指定输出文件路径,\n参数需要调用io.fullpath()转换为绝对路径,\n需要设GenerateInMemory为false取消内存编译,\n调用setGenerateExecutable指定编译为DLL或者EXE
Parameters.GenerateExecutable = 是否编译为EXE执行文件\n编译为DLL设为false
Parameters.GenerateInMemory = 是否内存编译
Parameters.CompilerOptions = @.CompilerOptions = "/optimize /unsafe"__/*编译参数，/optimize 为开启优化*/
getProvider() = 编译器
getLastError()  = 获取编译错误信息
Reference( = 引用程序集，System.dll 已默认添加\n\n注意这函数不支持内存 DLL，\n也不支持用 dotNet.reference 添加的内存 DLL。
Reference(.(assemblyPath,->->->) = 引用程序集,\n可指定任意多个程序集路径或名称参数,\n如果指定不含 dll 后缀名的程序集名，则加载程序集并转换为完整路径。
Reference(.(assemblyDir,subPath->->->) = 引用程序集,\n参数@1指定目录,可指定一个或多个子路径,\n使用 io.joinpath 函数合并参数转换为完整路径,\n然后引用该程序集。
Source = @.Source = /***\nusing System;\n\nnamespace CSharpLibrary  \n{\n	public class NetObject  \n	{\n		public NetObject()\n		{\n			__/*Source 属性可用字符串或字符串数组指定要编辑的代码。\n如果指定字符串则启用 aardio 模板语法，如果代码开始没有模板标记则自动添加。\n编译器对象的 ownerArgs 属性指定模板 owner 参数。\nCLR v2.0 / v4.0 可运行在 3.x,4.x 编译的 DLL，但编译器仅支持 CLR 相同版本语法。\n如果要添加文件，请改用 addSource 函数。*/\n		} \n	}\n} \n***/
Compile( = 编译并返回程序集
ownerArgs = 模板语法使用的 owner 参数，默认为表对象。
loadcode = 用于自定义板解析函数，\n用于解析启用 aardio 模板语法的 C# 代码。\n默认指向 string.loadcode 。
addSource( = 添加源码，使用此函数添加源码后 Source 属性将变为数组
addSource(.(code,rep) = 参数 @code 可以指定代码或代码文件路径。\n可指定嵌入资源路径，源文件必须使用 UTF-8 编码。\n如果代码开始的非空白空字为 <? 或  ?> 则启用 aardio 模板语法，\n编译器对象的 ownerArgs 属性指定模板 owner 参数。\n参数 @rep 指定是否丢弃之前添加的代码
defaultSource = 编译前默认添加到前面的代码
Compile(.(outpath) = 编译并返回程序集,所有参数可选,\n如果参数 @outpath 指定了输出 dll 或 exe 文件路径，则输出为文件,\n遇到错误不会抛出异常，请调用 getLastError 函数获取错误信息
Compile() = !dotNetCrlAssembly.
CompileOrFail( = 编译并返回程序集
CompileOrFail(.(outpath) = 编译并返回程序集,所有参数可选,\n如果参数 @outpath 指定了输出 dll 或 exe 文件路径，则输出为文件,\n遇到错误会抛出异常
CompileOrFail() = !dotNetCrlAssembly.
import( = 编译代码生成程序集，遇到错误会抛出异常。\n将 参数@1指定的名字空间或类导入 aardio 全局名字空间。\n在同一程序集中不会重复导入名字空间。\n\n如果程序集用不是用 load 函数加载，则有可能重复导入名字空间,\n重复导入 .NET 名字空间不会修改已存在的全局名字空间，\n但此函数总是会返回当前调用实际创建的名字空间
import(.(netNamespace) = 编译代码生成程序集，遇到错误会抛出异常。\n将 参数@1指定的名字空间或类导入 aardio 全局名字空间。\n必须指定完整名字空间,不传入参数则默认指定参数为程序集名称。\n\n返回名字空间可作为类构造函数调用并创建对象\n也可以用成员操作符返回静态成员，或调用静态函数。\n\n重复导入 .NET 名字空间不会修改已存在的全局名字空间，\n但此函数总是会返回当前调用实际创建的名字空间
import() = !dotNetNameSpace.
end intellisense****/

/**intellisense(!dotNetCrlAssembly)
appDomain = 加载此程序集的应用程序域\n!dotNetAppDomain.
Location = 获取完整路径
FullName = 获取程序集的全名
import( = 将 .NET 类名或名字空间导入 aardio 全局名字空间。\n在当前应用程序域 import,load 等函数不会导入重复的程序集，\n在同一程序集中不会重复导入名字空间。\n\n如果程序集用其他函数加载，则有可能重复导入名字空间,\n重复导入 .NET 名字空间不会修改已存在的全局名字空间，\n但此函数总是会返回当前调用实际创建的名字空间
import(.(netNamespace) = 将参数@1 指定的 .NET 类名或名字空间导入 aardio 全局名字空间，\n必须指定完整名字空间。\n参数 @1 可指定名字空间也可以指定要导入的名字空间数组。\n不传入参数则默认指定参数为程序集名称。\n\n返回名字空间可作为类构造函数调用并创建对象\n也可以用成员操作符返回静态成员，或调用静态函数。\n\n重复导入 .NET 名字空间不会修改已存在的全局名字空间，\n但此函数总是会返回当前调用实际创建的名字空间
import(.(netNamespace,->->->) = 参数@1 指定要导入的 .NET 类名。\n如果再指定一个或多个类型参数时则导入泛型类。\n类型参数可以是导入的 .NET 类、类名全称、System.Type.GetType 获取的类型对象。\n对导入的 .NET 类使用下标 ["<>"] 也可以返回一个创建泛型类的函数。\n泛型类不会缓存，也不会设为 aardio 全局名字空间
new(.("类名",->->-> ) = 创建对象实例,\n可添加不定个数构造参数\n失败返回空值,以及错误信息
invokeStaticMember(.("类名->方法名",->->-> ) = 调用类的静态方法,\n可添加不定个数调用参数\n失败返回空值,以及错误信息
getStaticMember(.("类名->字段名") = 获取字段或属性值、或枚举值
end intellisense**/

/**intellisense(!dotNetDelegate)
combine( = 合并委托\n在 .NET 里函数要转换为委托对象才能作为回调函数传输
combine(.(对象,委托成员名,委托对象) = 自参数@1指定的 .NET 对象中查询参数 @2指定的的属性或字段,\n如果该成员是一个 delegate 或 event 类型，则合并参数@2，@3指定的委托并更新该成员的值。\n原委托成员可为空值，但参数@1,@2 不可省略。\n\n参数 @3 可指定 .NET 委托对象、null 值或省略。\n如果参数 @3 是普通的 aardio 函数或表则转换为所需类型的 .NET 委托。\n此函数返回参数@3创建的委托对象,可用于 remove 函数.
combine(.(委托对象1,委托对象2) = 返回合并的委托对象,允许省略所有参数，\n如果指定参数则至少有一个 .NET 委托对象，\n另一个参数可以是委托对象，也可指定普通 aardio 函数或表,\n如果是普通 aardio 表则回调 _call 元方法,\naardio 函数或表参数会自动转换为所需类型的 .NET 委托	
remove( = 移除委托
remove(.(对象,委托成员名,委托对象) = 自参数@1指定的 .NET 对象中查询参数 @2指定的的属性或字段,\n如果该成员是一个 delegate 或 event 类型，则移除参数@3指定的委托并更新该成员的值。\n原委托成员可为空值，但参数@1,@2 不可省略。\n\n参数 @3 指定需要移除的 .NET 委托对象。\n不指定参数 @3 则不执行任何操作。\n移除成功返回 true，失败返回 false
remove(.(委托对象1,委托对象2) = 自参数@1指定的委托中移除以参数@2指定的委托，\n所有参数必须是 .NET 委托对象,\n成功返回新的委托，\n失败或委托调用链没有变化返回 null,\n任何一个参数为 null 返回 null
create( = 创建委托\n在 .NET 里函数要转换为委托对象才能作为回调函数传输
create(.(对象,委托成员名,函数对象) = 自参数@1指定的 .NET 对象中查询参数 @2指定的的属性或字段,\n如果该成员是一个 delegate 或 event 类型，\n则将@3指定的函数转换为该类型的委托对象并返回
list(__) = 返回参数 @1 指定委托对象的调用对象列表,\n相当于调用委托对象的 GetInvocationList 函数。
end intellisense**/

/**intellisense(!dotNetNameSpace)
__assembly__ = 导入此 .NET 名字空间的程序集对象。\n!dotNetCrlAssembly.
? = .NET 名字空间、类、结构体的成员，\n可访问成员名字空间、类、枚举、静态属性或字段，\n导入的类可用于构造 .NET 对象，传回 .NET 则自动转为该类的 Type 对象。\n通过下标 ["<>"] 可返回一个创建泛型类的函数，函数参数为类型对象或完整类型名称。\n!dotNetNameSpace.
end intellisense**/