//es5 补丁
import web.script;

namespace web.script.es5{};

namespace web.script.preload.es5 begin

language = {
	javascript = true;
	jscript = true;
	jscript9 = true; 
}

//@ENDDOCUMENT@//
// es5-shim & es5-sham:https://github.com/es-shims/es5-shim/blob/master/LICENSE
code = /**********
;(function (root, factory) {
'use strict';
if (typeof define === 'function' && define.amd) {
define(factory);
} else if (typeof exports === 'object') {
module.exports = factory();
} else {
root.returnExports = factory(); 
}
}(this, function () {
var $Array = Array;
var ArrayPrototype = $Array.prototype;
var $Object = Object;
var ObjectPrototype = $Object.prototype;
var $Function = Function;
var FunctionPrototype = $Function.prototype;
var $String = String;
var StringPrototype = $String.prototype;
var $Number = Number;
var NumberPrototype = $Number.prototype;
var array_slice = ArrayPrototype.slice;
var array_splice = ArrayPrototype.splice;
var array_push = ArrayPrototype.push;
var array_unshift = ArrayPrototype.unshift;
var array_concat = ArrayPrototype.concat;
var array_join = ArrayPrototype.join;
var call = FunctionPrototype.call;
var apply = FunctionPrototype.apply;
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var abs = Math.abs;
var pow = Math.pow;
var round = Math.round;
var log = Math.log;
var LOG10E = Math.LOG10E;
var log10 = Math.log10 || function log10(value) {
return log(value) * LOG10E;
};
var to_string = ObjectPrototype.toString;
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var isCallable; var fnToStr = Function.prototype.toString, constructorRegex = /^\s*class /, isES6ClassFn = function isES6ClassFn(value) { try { var fnStr = fnToStr.call(value); var singleStripped = fnStr.replace(/\/\/.*\n/g, ''); var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, ''); var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' '); return constructorRegex.test(spaceStripped); } catch (e) { return false; /* not a function */ } }, tryFunctionObject = function tryFunctionObject(value) { try { if (isES6ClassFn(value)) { return false; } fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]', isCallable = function isCallable(value) { if (!value) { return false; } if (typeof value !== 'function' && typeof value !== 'object') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } if (isES6ClassFn(value)) { return false; } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };

var isRegex; var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
var isString; var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };

var supportsDescriptors = $Object.defineProperty && (function () {
try {
var obj = {};
$Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
for (var _ in obj) { return false; } 
return obj.x === obj;
} catch (e) { 
return false;
}
}());
var defineProperties = (function (has) {
var defineProperty;
if (supportsDescriptors) {
defineProperty = function (object, name, method, forceAssign) {
if (!forceAssign && (name in object)) {
return;
}
$Object.defineProperty(object, name, {
configurable: true,
enumerable: false,
writable: true,
value: method
});
};
} else {
defineProperty = function (object, name, method, forceAssign) {
if (!forceAssign && (name in object)) {
return;
}
object[name] = method; 
};
}
return function defineProperties(object, map, forceAssign) {
for (var name in map) {
if (has.call(map, name)) {
defineProperty(object, name, map[name], forceAssign);
}
}
};
}(ObjectPrototype.hasOwnProperty));
if ($Object.defineProperty && supportsDescriptors) {
var F = function () {};
var toStringSentinel = {};
var sentinel = { toString: toStringSentinel };
$Object.defineProperty(F, 'prototype', { value: sentinel, writable: false });
if ((new F()).toString !== toStringSentinel) {
var $dP = $Object.defineProperty;
var $gOPD = $Object.getOwnPropertyDescriptor;
defineProperties($Object, {
defineProperty: function defineProperty(o, k, d) {
var key = $String(k);
if (typeof o === 'function' && key === 'prototype') {
var desc = $gOPD(o, key);
if (desc.writable && !d.writable && 'value' in d) {
try {
o[key] = d.value; 
} catch (e) {}
}
return $dP(o, key, {
configurable: 'configurable' in d ? d.configurable : desc.configurable,
enumerable: 'enumerable' in d ? d.enumerable : desc.enumerable,
writable: d.writable
});
}
return $dP(o, key, d);
}
}, true);
}
}
var isPrimitive = function isPrimitive(input) {
var type = typeof input;
return input === null || (type !== 'object' && type !== 'function');
};

var isActualNaN = $Number.isNaN || function isActualNaN(x) {
return x !== x;
};

var ES = {
ToInteger: function ToInteger(num) {
var n = +num;
if (isActualNaN(n)) {
n = 0;
} else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
n = (n > 0 || -1) * floor(abs(n));
}
return n;
},
ToPrimitive: function ToPrimitive(input) {
var val, valueOf, toStr;
if (isPrimitive(input)) {
return input;
}
valueOf = input.valueOf;
if (isCallable(valueOf)) {
val = valueOf.call(input);
if (isPrimitive(val)) {
return val;
}
}
toStr = input.toString;
if (isCallable(toStr)) {
val = toStr.call(input);
if (isPrimitive(val)) {
return val;
}
}
throw new TypeError();
},
ToObject: function (o) {
if (o == null) { // this matches both null and undefined
throw new TypeError("can't convert " + o + ' to object');
}
return $Object(o);
},
ToUint32: function ToUint32(x) {
return x >>> 0;
}
};

var Empty = function Empty() {};

defineProperties(FunctionPrototype, {
bind: function bind(that) {
var target = this;
if (!isCallable(target)) {
throw new TypeError('Function.prototype.bind called on incompatible ' + target);
}
var args = array_slice.call(arguments, 1); // for normal call
var bound;
var binder = function () {

if (this instanceof bound) {

var result = apply.call(
target,
this,
array_concat.call(args, array_slice.call(arguments))
);
if ($Object(result) === result) {
return result;
}
return this;

}

return apply.call(
target,
that,
array_concat.call(args, array_slice.call(arguments))
);

};

var boundLength = max(0, target.length - args.length);
var boundArgs = [];
for (var i = 0; i < boundLength; i++) {
array_push.call(boundArgs, '$' + i);
}
bound = $Function('binder', 'return function (' + array_join.call(boundArgs, ',') + '){ return binder.apply(this, arguments); }')(binder);

if (target.prototype) {
Empty.prototype = target.prototype;
bound.prototype = new Empty();
Empty.prototype = null;
}

return bound;
}
});
var owns = call.bind(ObjectPrototype.hasOwnProperty);
var toStr = call.bind(ObjectPrototype.toString);
var arraySlice = call.bind(array_slice);
var arraySliceApply = apply.bind(array_slice);
if (typeof document === 'object' && document && document.documentElement) {
try {
arraySlice(document.documentElement.childNodes);
} catch (e) {
var origArraySlice = arraySlice;
var origArraySliceApply = arraySliceApply;
arraySlice = function arraySliceIE(arr) {
var r = [];
var i = arr.length;
while (i-- > 0) {
r[i] = arr[i];
}
return origArraySliceApply(r, origArraySlice(arguments, 1));
};
arraySliceApply = function arraySliceApplyIE(arr, args) {
return origArraySliceApply(arraySlice(arr), args);
};
}
}
var strSlice = call.bind(StringPrototype.slice);
var strSplit = call.bind(StringPrototype.split);
var strIndexOf = call.bind(StringPrototype.indexOf);
var pushCall = call.bind(array_push);
var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
var arraySort = call.bind(ArrayPrototype.sort);

var isArray = $Array.isArray || function isArray(obj) {
return toStr(obj) === '[object Array]';
};
var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
defineProperties(ArrayPrototype, {
unshift: function () {
array_unshift.apply(this, arguments);
return this.length;
}
}, hasUnshiftReturnValueBug);
defineProperties($Array, { isArray: isArray });


var boxedString = $Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
var properlyBoxesNonStrict = true;
var properlyBoxesStrict = true;
var threwException = false;
if (method) {
try {
method.call('foo', function (_, __, context) {
if (typeof context !== 'object') {
properlyBoxesNonStrict = false;
}
});

method.call([1], function () {
'use strict';

properlyBoxesStrict = typeof this === 'string';
}, 'x');
} catch (e) {
threwException = true;
}
}
return !!method && !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
forEach: function forEach(callbackfn/*, thisArg*/) {
var object = ES.ToObject(this);
var self = splitString && isString(this) ? strSplit(this, '') : object;
var i = -1;
var length = ES.ToUint32(self.length);
var T;
if (arguments.length > 1) {
T = arguments[1];
}
if (!isCallable(callbackfn)) {
throw new TypeError('Array.prototype.forEach callback must be a function');
}

while (++i < length) {
if (i in self) {
if (typeof T === 'undefined') {
callbackfn(self[i], i, object);
} else {
callbackfn.call(T, self[i], i, object);
}
}
}
}
}, !properlyBoxesContext(ArrayPrototype.forEach));
defineProperties(ArrayPrototype, {
map: function map(callbackfn/*, thisArg*/) {
var object = ES.ToObject(this);
var self = splitString && isString(this) ? strSplit(this, '') : object;
var length = ES.ToUint32(self.length);
var result = $Array(length);
var T;
if (arguments.length > 1) {
T = arguments[1];
}
if (!isCallable(callbackfn)) {
throw new TypeError('Array.prototype.map callback must be a function');
}

for (var i = 0; i < length; i++) {
if (i in self) {
if (typeof T === 'undefined') {
result[i] = callbackfn(self[i], i, object);
} else {
result[i] = callbackfn.call(T, self[i], i, object);
}
}
}
return result;
}
}, !properlyBoxesContext(ArrayPrototype.map));
defineProperties(ArrayPrototype, {
filter: function filter(callbackfn/*, thisArg*/) {
var object = ES.ToObject(this);
var self = splitString && isString(this) ? strSplit(this, '') : object;
var length = ES.ToUint32(self.length);
var result = [];
var value;
var T;
if (arguments.length > 1) {
T = arguments[1];
}
if (!isCallable(callbackfn)) {
throw new TypeError('Array.prototype.filter callback must be a function');
}

for (var i = 0; i < length; i++) {
if (i in self) {
value = self[i];
if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
pushCall(result, value);
}
}
}
return result;
}
}, !properlyBoxesContext(ArrayPrototype.filter));
defineProperties(ArrayPrototype, {
every: function every(callbackfn/*, thisArg*/) {
var object = ES.ToObject(this);
var self = splitString && isString(this) ? strSplit(this, '') : object;
var length = ES.ToUint32(self.length);
var T;
if (arguments.length > 1) {
T = arguments[1];
}
if (!isCallable(callbackfn)) {
throw new TypeError('Array.prototype.every callback must be a function');
}

for (var i = 0; i < length; i++) {
if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
return false;
}
}
return true;
}
}, !properlyBoxesContext(ArrayPrototype.every));
defineProperties(ArrayPrototype, {
some: function some(callbackfn) {
var object = ES.ToObject(this);
var self = splitString && isString(this) ? strSplit(this, '') : object;
var length = ES.ToUint32(self.length);
var T;
if (arguments.length > 1) {
T = arguments[1];
}
if (!isCallable(callbackfn)) {
throw new TypeError('Array.prototype.some callback must be a function');
}

for (var i = 0; i < length; i++) {
if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
return true;
}
}
return false;
}
}, !properlyBoxesContext(ArrayPrototype.some));
var reduceCoercesToObject = false;
if (ArrayPrototype.reduce) {
reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) {
return list;
}) === 'object';
}
defineProperties(ArrayPrototype, {
reduce: function reduce(callbackfn/*, initialValue*/) {
var object = ES.ToObject(this);
var self = splitString && isString(this) ? strSplit(this, '') : object;
var length = ES.ToUint32(self.length);
if (!isCallable(callbackfn)) {
throw new TypeError('Array.prototype.reduce callback must be a function');
}
if (length === 0 && arguments.length === 1) {
throw new TypeError('reduce of empty array with no initial value');
}

var i = 0;
var result;
if (arguments.length >= 2) {
result = arguments[1];
} else {
do {
if (i in self) {
result = self[i++];
break;
}
if (++i >= length) {
throw new TypeError('reduce of empty array with no initial value');
}
} while (true);
}

for (; i < length; i++) {
if (i in self) {
result = callbackfn(result, self[i], i, object);
}
}

return result;
}
}, !reduceCoercesToObject);
var reduceRightCoercesToObject = false;
if (ArrayPrototype.reduceRight) {
reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) {
return list;
}) === 'object';
}
defineProperties(ArrayPrototype, {
reduceRight: function reduceRight(callbackfn) {
var object = ES.ToObject(this);
var self = splitString && isString(this) ? strSplit(this, '') : object;
var length = ES.ToUint32(self.length);
if (!isCallable(callbackfn)) {
throw new TypeError('Array.prototype.reduceRight callback must be a function');
}
if (length === 0 && arguments.length === 1) {
throw new TypeError('reduceRight of empty array with no initial value');
}

var result;
var i = length - 1;
if (arguments.length >= 2) {
result = arguments[1];
} else {
do {
if (i in self) {
result = self[i--];
break;
}
if (--i < 0) {
throw new TypeError('reduceRight of empty array with no initial value');
}
} while (true);
}

if (i < 0) {
return result;
}

do {
if (i in self) {
result = callbackfn(result, self[i], i, object);
}
} while (i--);

return result;
}
}, !reduceRightCoercesToObject);
var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
indexOf: function indexOf(searchElement) {
var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
var length = ES.ToUint32(self.length);

if (length === 0) {
return -1;
}

var i = 0;
if (arguments.length > 1) {
i = ES.ToInteger(arguments[1]);
}
i = i >= 0 ? i : max(0, length + i);
for (; i < length; i++) {
if (i in self && self[i] === searchElement) {
return i;
}
}
return -1;
}
}, hasFirefox2IndexOfBug);
var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
defineProperties(ArrayPrototype, {
lastIndexOf: function lastIndexOf(searchElement) {
var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
var length = ES.ToUint32(self.length);

if (length === 0) {
return -1;
}
var i = length - 1;
if (arguments.length > 1) {
i = min(i, ES.ToInteger(arguments[1]));
}
i = i >= 0 ? i : length - abs(i);
for (; i >= 0; i--) {
if (i in self && searchElement === self[i]) {
return i;
}
}
return -1;
}
}, hasFirefox2LastIndexOfBug);
var spliceNoopReturnsEmptyArray = (function () {
var a = [1, 2];
var result = a.splice();
return a.length === 2 && isArray(result) && result.length === 0;
}());
defineProperties(ArrayPrototype, {
splice: function splice(start, deleteCount) {
if (arguments.length === 0) {
return [];
}
return array_splice.apply(this, arguments);

}
}, !spliceNoopReturnsEmptyArray);

var spliceWorksWithEmptyObject = (function () {
var obj = {};
ArrayPrototype.splice.call(obj, 0, 0, 1);
return obj.length === 1;
}());
var hasES6Defaults = [0, 1, 2].splice(0).length === 3;
defineProperties(ArrayPrototype, {
splice: function splice(start, deleteCount) {
if (arguments.length === 0) {
return [];
}
var args = arguments;
this.length = max(ES.ToInteger(this.length), 0);
if (arguments.length > 0 && typeof deleteCount !== 'number') {
args = arraySlice(arguments);
if (args.length < 2) {
pushCall(args, this.length - start);
} else {
args[1] = ES.ToInteger(deleteCount);
}
}
return array_splice.apply(this, args);
}
}, !spliceWorksWithEmptyObject || !hasES6Defaults);
var spliceWorksWithLargeSparseArrays = (function () {
var arr = new $Array(1e5);
arr[8] = 'x';
arr.splice(1, 1);
return arr.indexOf('x') === 7;
}());
var spliceWorksWithSmallSparseArrays = (function () {
var n = 256;
var arr = [];
arr[n] = 'a';
arr.splice(n + 1, 0, 'b');
return arr[n] === 'a';
}());
defineProperties(ArrayPrototype, {
splice: function splice(start, deleteCount) {
var O = ES.ToObject(this);
var A = [];
var len = ES.ToUint32(O.length);
var relativeStart = ES.ToInteger(start);
var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
var actualDeleteCount = arguments.length === 0
? 0
: arguments.length === 1
? len - actualStart
: min(max(ES.ToInteger(deleteCount), 0), len - actualStart);

var k = 0;
var from;
while (k < actualDeleteCount) {
from = $String(actualStart + k);
if (owns(O, from)) {
A[k] = O[from];
}
k += 1;
}

var items = arraySlice(arguments, 2);
var itemCount = items.length;
var to;
if (itemCount < actualDeleteCount) {
k = actualStart;
var maxK = len - actualDeleteCount;
while (k < maxK) {
from = $String(k + actualDeleteCount);
to = $String(k + itemCount);
if (owns(O, from)) {
O[to] = O[from];
} else {
delete O[to];
}
k += 1;
}
k = len;
var minK = len - actualDeleteCount + itemCount;
while (k > minK) {
delete O[k - 1];
k -= 1;
}
} else if (itemCount > actualDeleteCount) {
k = len - actualDeleteCount;
while (k > actualStart) {
from = $String(k + actualDeleteCount - 1);
to = $String(k + itemCount - 1);
if (owns(O, from)) {
O[to] = O[from];
} else {
delete O[to];
}
k -= 1;
}
}
k = actualStart;
for (var i = 0; i < items.length; ++i) {
O[k] = items[i];
k += 1;
}
O.length = len - actualDeleteCount + itemCount;

return A;
}
}, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);

var originalJoin = ArrayPrototype.join;
var hasStringJoinBug;
try {
hasStringJoinBug = Array.prototype.join.call('123', ',') !== '1,2,3';
} catch (e) {
hasStringJoinBug = true;
}
if (hasStringJoinBug) {
defineProperties(ArrayPrototype, {
join: function join(separator) {
var sep = typeof separator === 'undefined' ? ',' : separator;
return originalJoin.call(isString(this) ? strSplit(this, '') : this, sep);
}
}, hasStringJoinBug);
}

var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
if (hasJoinUndefinedBug) {
defineProperties(ArrayPrototype, {
join: function join(separator) {
var sep = typeof separator === 'undefined' ? ',' : separator;
return originalJoin.call(this, sep);
}
}, hasJoinUndefinedBug);
}

var pushShim = function push(item) {
var O = ES.ToObject(this);
var n = ES.ToUint32(O.length);
var i = 0;
while (i < arguments.length) {
O[n + i] = arguments[i];
i += 1;
}
O.length = n + i;
return n + i;
};

var pushIsNotGeneric = (function () {
var obj = {};
var result = Array.prototype.push.call(obj, undefined);
return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
}());
defineProperties(ArrayPrototype, {
push: function push(item) {
if (isArray(this)) {
return array_push.apply(this, arguments);
}
return pushShim.apply(this, arguments);
}
}, pushIsNotGeneric);
var pushUndefinedIsWeird = (function () {
var arr = [];
var result = arr.push(undefined);
return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
}());
defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);
defineProperties(ArrayPrototype, {
slice: function (start, end) {
var arr = isString(this) ? strSplit(this, '') : this;
return arraySliceApply(arr, arguments);
}
}, splitString);

var sortIgnoresNonFunctions = (function () {
try {
[1, 2].sort(null);
} catch (e) {
try {
[1, 2].sort({});
} catch (e2) {
return false;
}
}
return true;
}());
var sortThrowsOnRegex = (function () {
try {
[1, 2].sort(/a/);
return false;
} catch (e) {}
return true;
}());
var sortIgnoresUndefined = (function () {
try {
[1, 2].sort(undefined);
return true;
} catch (e) {}
return false;
}());
defineProperties(ArrayPrototype, {
sort: function sort(compareFn) {
if (typeof compareFn === 'undefined') {
return arraySort(this);
}
if (!isCallable(compareFn)) {
throw new TypeError('Array.prototype.sort callback must be a function');
}
return arraySort(this, compareFn);
}
}, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);
var hasDontEnumBug = !isEnum({ 'toString': null }, 'toString'); // jscs:ignore disallowQuotedKeysInObjects
var hasProtoEnumBug = isEnum(function () {}, 'prototype');
var hasStringEnumBug = !owns('x', '0');
var equalsConstructorPrototype = function (o) {
var ctor = o.constructor;
return ctor && ctor.prototype === o;
};
var excludedKeys = {
$applicationCache: true,
$console: true,
$external: true,
$frame: true,
$frameElement: true,
$frames: true,
$innerHeight: true,
$innerWidth: true,
$onmozfullscreenchange: true,
$onmozfullscreenerror: true,
$outerHeight: true,
$outerWidth: true,
$pageXOffset: true,
$pageYOffset: true,
$parent: true,
$scrollLeft: true,
$scrollTop: true,
$scrollX: true,
$scrollY: true,
$self: true,
$webkitIndexedDB: true,
$webkitStorageInfo: true,
$window: true,

$width: true,
$height: true,
$top: true,
$localStorage: true
};
var hasAutomationEqualityBug = (function () {
if (typeof window === 'undefined') {
return false;
}
for (var k in window) {
try {
if (!excludedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
equalsConstructorPrototype(window[k]);
}
} catch (e) {
return true;
}
}
return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (object) {
if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
return equalsConstructorPrototype(object);
}
try {
return equalsConstructorPrototype(object);
} catch (e) {
return false;
}
};
var dontEnums = [
'toString',
'toLocaleString',
'valueOf',
'hasOwnProperty',
'isPrototypeOf',
'propertyIsEnumerable',
'constructor'
];
var dontEnumsLength = dontEnums.length;
var isStandardArguments = function isArguments(value) {
return toStr(value) === '[object Arguments]';
};
var isLegacyArguments = function isArguments(value) {
return value !== null
&& typeof value === 'object'
&& typeof value.length === 'number'
&& value.length >= 0
&& !isArray(value)
&& isCallable(value.callee);
};
var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

defineProperties($Object, {
keys: function keys(object) {
var isFn = isCallable(object);
var isArgs = isArguments(object);
var isObject = object !== null && typeof object === 'object';
var isStr = isObject && isString(object);

if (!isObject && !isFn && !isArgs) {
throw new TypeError('Object.keys called on a non-object');
}

var theKeys = [];
var skipProto = hasProtoEnumBug && isFn;
if ((isStr && hasStringEnumBug) || isArgs) {
for (var i = 0; i < object.length; ++i) {
pushCall(theKeys, $String(i));
}
}

if (!isArgs) {
for (var name in object) {
if (!(skipProto && name === 'prototype') && owns(object, name)) {
pushCall(theKeys, $String(name));
}
}
}

if (hasDontEnumBug) {
var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
for (var j = 0; j < dontEnumsLength; j++) {
var dontEnum = dontEnums[j];
if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
pushCall(theKeys, dontEnum);
}
}
}
return theKeys;
}
});

var keysWorksWithArguments = $Object.keys && (function () {
return $Object.keys(arguments).length === 2;
}(1, 2));
var keysHasArgumentsLengthBug = $Object.keys && (function () {
var argKeys = $Object.keys(arguments);
return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
}(1));
var originalKeys = $Object.keys;
defineProperties($Object, {
keys: function keys(object) {
if (isArguments(object)) {
return originalKeys(arraySlice(object));
}
return originalKeys(object);

}
}, !keysWorksWithArguments || keysHasArgumentsLengthBug);

var hasNegativeMonthYearBug = new Date(-3509827329600292).getUTCMonth() !== 0;
var aNegativeTestDate = new Date(-1509842289600292);
var aPositiveTestDate = new Date(1449662400000);
var hasToUTCStringFormatBug = aNegativeTestDate.toUTCString() !== 'Mon, 01 Jan -45875 11:59:59 GMT';
var hasToDateStringFormatBug;
var hasToStringFormatBug;
var timeZoneOffset = aNegativeTestDate.getTimezoneOffset();
if (timeZoneOffset < -720) {
hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Tue Jan 02 -45875';
hasToStringFormatBug = !(/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/).test(String(aPositiveTestDate));
} else {
hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Mon Jan 01 -45875';
hasToStringFormatBug = !(/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/).test(String(aPositiveTestDate));
}

var originalGetFullYear = call.bind(Date.prototype.getFullYear);
var originalGetMonth = call.bind(Date.prototype.getMonth);
var originalGetDate = call.bind(Date.prototype.getDate);
var originalGetUTCFullYear = call.bind(Date.prototype.getUTCFullYear);
var originalGetUTCMonth = call.bind(Date.prototype.getUTCMonth);
var originalGetUTCDate = call.bind(Date.prototype.getUTCDate);
var originalGetUTCDay = call.bind(Date.prototype.getUTCDay);
var originalGetUTCHours = call.bind(Date.prototype.getUTCHours);
var originalGetUTCMinutes = call.bind(Date.prototype.getUTCMinutes);
var originalGetUTCSeconds = call.bind(Date.prototype.getUTCSeconds);
var originalGetUTCMilliseconds = call.bind(Date.prototype.getUTCMilliseconds);
var dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
var monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var daysInMonth = function daysInMonth(month, year) {
return originalGetDate(new Date(year, month, 0));
};

defineProperties(Date.prototype, {
getFullYear: function getFullYear() {
if (!this || !(this instanceof Date)) {
throw new TypeError('this is not a Date object.');
}
var year = originalGetFullYear(this);
if (year < 0 && originalGetMonth(this) > 11) {
return year + 1;
}
return year;
},
getMonth: function getMonth() {
if (!this || !(this instanceof Date)) {
throw new TypeError('this is not a Date object.');
}
var year = originalGetFullYear(this);
var month = originalGetMonth(this);
if (year < 0 && month > 11) {
return 0;
}
return month;
},
getDate: function getDate() {
if (!this || !(this instanceof Date)) {
throw new TypeError('this is not a Date object.');
}
var year = originalGetFullYear(this);
var month = originalGetMonth(this);
var date = originalGetDate(this);
if (year < 0 && month > 11) {
if (month === 12) {
return date;
}
var days = daysInMonth(0, year + 1);
return (days - date) + 1;
}
return date;
},
getUTCFullYear: function getUTCFullYear() {
if (!this || !(this instanceof Date)) {
throw new TypeError('this is not a Date object.');
}
var year = originalGetUTCFullYear(this);
if (year < 0 && originalGetUTCMonth(this) > 11) {
return year + 1;
}
return year;
},
getUTCMonth: function getUTCMonth() {
if (!this || !(this instanceof Date)) {
throw new TypeError('this is not a Date object.');
}
var year = originalGetUTCFullYear(this);
var month = originalGetUTCMonth(this);
if (year < 0 && month > 11) {
return 0;
}
return month;
},
getUTCDate: function getUTCDate() {
if (!this || !(this instanceof Date)) {
throw new TypeError('this is not a Date object.');
}
var year = originalGetUTCFullYear(this);
var month = originalGetUTCMonth(this);
var date = originalGetUTCDate(this);
if (year < 0 && month > 11) {
if (month === 12) {
return date;
}
var days = daysInMonth(0, year + 1);
return (days - date) + 1;
}
return date;
}
}, hasNegativeMonthYearBug);

defineProperties(Date.prototype, {
toUTCString: function toUTCString() {
if (!this || !(this instanceof Date)) {
throw new TypeError('this is not a Date object.');
}
var day = originalGetUTCDay(this);
var date = originalGetUTCDate(this);
var month = originalGetUTCMonth(this);
var year = originalGetUTCFullYear(this);
var hour = originalGetUTCHours(this);
var minute = originalGetUTCMinutes(this);
var second = originalGetUTCSeconds(this);
return dayName[day] + ', '
+ (date < 10 ? '0' + date : date) + ' '
+ monthName[month] + ' '
+ year + ' '
+ (hour < 10 ? '0' + hour : hour) + ':'
+ (minute < 10 ? '0' + minute : minute) + ':'
+ (second < 10 ? '0' + second : second) + ' GMT';
}
}, hasNegativeMonthYearBug || hasToUTCStringFormatBug);
defineProperties(Date.prototype, {
toDateString: function toDateString() {
if (!this || !(this instanceof Date)) {
throw new TypeError('this is not a Date object.');
}
var day = this.getDay();
var date = this.getDate();
var month = this.getMonth();
var year = this.getFullYear();
return dayName[day] + ' '
+ monthName[month] + ' '
+ (date < 10 ? '0' + date : date) + ' '
+ year;
}
}, hasNegativeMonthYearBug || hasToDateStringFormatBug);
if (hasNegativeMonthYearBug || hasToStringFormatBug) {
Date.prototype.toString = function toString() {
if (!this || !(this instanceof Date)) {
throw new TypeError('this is not a Date object.');
}
var day = this.getDay();
var date = this.getDate();
var month = this.getMonth();
var year = this.getFullYear();
var hour = this.getHours();
var minute = this.getMinutes();
var second = this.getSeconds();
var timezoneOffset = this.getTimezoneOffset();
var hoursOffset = floor(abs(timezoneOffset) / 60);
var minutesOffset = floor(abs(timezoneOffset) % 60);
return dayName[day] + ' '
+ monthName[month] + ' '
+ (date < 10 ? '0' + date : date) + ' '
+ year + ' '
+ (hour < 10 ? '0' + hour : hour) + ':'
+ (minute < 10 ? '0' + minute : minute) + ':'
+ (second < 10 ? '0' + second : second) + ' GMT'
+ (timezoneOffset > 0 ? '-' : '+')
+ (hoursOffset < 10 ? '0' + hoursOffset : hoursOffset)
+ (minutesOffset < 10 ? '0' + minutesOffset : minutesOffset);
};
if (supportsDescriptors) {
$Object.defineProperty(Date.prototype, 'toString', {
configurable: true,
enumerable: false,
writable: true
});
}
}
var negativeDate = -62198755200000;
var negativeYearString = '-000001';
var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1; 
var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';

var getTime = call.bind(Date.prototype.getTime);

defineProperties(Date.prototype, {
toISOString: function toISOString() {
if (!isFinite(this) || !isFinite(getTime(this))) {
throw new RangeError('Date.prototype.toISOString called on non-finite value.');
}

var year = originalGetUTCFullYear(this);

var month = originalGetUTCMonth(this);
year += floor(month / 12);
month = ((month % 12) + 12) % 12;
var result = [
month + 1,
originalGetUTCDate(this),
originalGetUTCHours(this),
originalGetUTCMinutes(this),
originalGetUTCSeconds(this)
];
year = (
(year < 0 ? '-' : (year > 9999 ? '+' : ''))
+ strSlice('00000' + abs(year), (0 <= year && year <= 9999) ? -4 : -6)
);

for (var i = 0; i < result.length; ++i) {
result[i] = strSlice('00' + result[i], -2);
}
return (
year + '-' + arraySlice(result, 0, 2).join('-')
+ 'T' + arraySlice(result, 2).join(':') + '.'
+ strSlice('000' + originalGetUTCMilliseconds(this), -3) + 'Z'
);
}
}, hasNegativeDateBug || hasSafari51DateBug);
var dateToJSONIsSupported = (function () {
try {
return Date.prototype.toJSON
&& new Date(NaN).toJSON() === null
&& new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1
&& Date.prototype.toJSON.call({ // generic
toISOString: function () { return true; }
});
} catch (e) {
return false;
}
}());
if (!dateToJSONIsSupported) {
Date.prototype.toJSON = function toJSON(key) {
var O = $Object(this);
var tv = ES.ToPrimitive(O);
if (typeof tv === 'number' && !isFinite(tv)) {
return null;
}
var toISO = O.toISOString;
if (!isCallable(toISO)) {
throw new TypeError('toISOString property is not callable');
}
return toISO.call(O);
};
}
var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
var maxSafeUnsigned32Bit = pow(2, 31) - 1;
var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
Date = (function (NativeDate) {
var DateShim = function Date(Y, M, D, h, m, s, ms) {
var length = arguments.length;
var date;
if (this instanceof NativeDate) {
var seconds = s;
var millis = ms;
if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
var msToShift = floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
var sToShift = floor(msToShift / 1e3);
seconds += sToShift;
millis -= sToShift * 1e3;
}
var parsed = DateShim.parse(Y);
var hasNegTimestampParseBug = isNaN(parsed);
date = length === 1 && $String(Y) === Y && !hasNegTimestampParseBug // isString(Y)
? new NativeDate(parsed)
: length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis)
: length >= 6 ? new NativeDate(Y, M, D, h, m, seconds)
: length >= 5 ? new NativeDate(Y, M, D, h, m)
: length >= 4 ? new NativeDate(Y, M, D, h)
: length >= 3 ? new NativeDate(Y, M, D)
: length >= 2 ? new NativeDate(Y, M)
: length >= 1 ? new NativeDate(Y instanceof NativeDate ? +Y : Y)
: new NativeDate();
} else {
date = NativeDate.apply(this, arguments);
}
if (!isPrimitive(date)) {
defineProperties(date, { constructor: DateShim }, true);
}
return date;
};
var isoDateExpression = new RegExp('^'
+ '(\\d{4}|[+-]\\d{6})' // four-digit year capture or sign + 6-digit extended year
+ '(?:-(\\d{2})' // optional month capture
+ '(?:-(\\d{2})' // optional day capture
+ '(?:' // capture hours:minutes:seconds.milliseconds
+ 'T(\\d{2})' // hours capture
+ ':(\\d{2})' // minutes capture
+ '(?:' // optional :seconds.milliseconds
+ ':(\\d{2})' // seconds capture
+ '(?:(\\.\\d{1,}))?' // milliseconds capture
+ ')?'
+ '(' // capture UTC offset component
+ 'Z|' // UTC capture
+ '(?:' // offset specifier +/-hours:minutes
+ '([-+])' // sign capture
+ '(\\d{2})' // hours offset capture
+ ':(\\d{2})' // minutes offset capture
+ ')'
+ ')?)?)?)?'
+ '$');

var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];

var dayFromMonth = function dayFromMonth(year, month) {
var t = month > 1 ? 1 : 0;
return (
months[month]
+ floor((year - 1969 + t) / 4)
- floor((year - 1901 + t) / 100)
+ floor((year - 1601 + t) / 400)
+ (365 * (year - 1970))
);
};

var toUTC = function toUTC(t) {
var s = 0;
var ms = t;
if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
var msToShift = floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
var sToShift = floor(msToShift / 1e3);
s += sToShift;
ms -= sToShift * 1e3;
}
return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
};
for (var key in NativeDate) {
if (owns(NativeDate, key)) {
DateShim[key] = NativeDate[key];
}
}
defineProperties(DateShim, {
now: NativeDate.now,
UTC: NativeDate.UTC
}, true);
DateShim.prototype = NativeDate.prototype;
defineProperties(DateShim.prototype, { constructor: DateShim }, true);
var parseShim = function parse(string) {
var match = isoDateExpression.exec(string);
if (match) {
var year = $Number(match[1]),
month = $Number(match[2] || 1) - 1,
day = $Number(match[3] || 1) - 1,
hour = $Number(match[4] || 0),
minute = $Number(match[5] || 0),
second = $Number(match[6] || 0),
millisecond = floor($Number(match[7] || 0) * 1000),
isLocalTime = Boolean(match[4] && !match[8]),
signOffset = match[9] === '-' ? 1 : -1,
hourOffset = $Number(match[10] || 0),
minuteOffset = $Number(match[11] || 0),
result;
var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
if (
hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25)
&& minute < 60 && second < 60 && millisecond < 1000
&& month > -1 && month < 12 && hourOffset < 24
&& minuteOffset < 60 // detect invalid offsets
&& day > -1
&& day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
) {
result = (
((dayFromMonth(year, month) + day) * 24)
+ hour
+ (hourOffset * signOffset)
) * 60;
result = ((
((result + minute + (minuteOffset * signOffset)) * 60)
+ second
) * 1000) + millisecond;
if (isLocalTime) {
result = toUTC(result);
}
if (-8.64e15 <= result && result <= 8.64e15) {
return result;
}
}
return NaN;
}
return NativeDate.parse.apply(this, arguments);
};
defineProperties(DateShim, { parse: parseShim });

return DateShim;
}(Date));
}
if (!Date.now) {
Date.now = function now() {
return new Date().getTime();
};
}
var hasToFixedBugs = NumberPrototype.toFixed && (
(0.00008).toFixed(3) !== '0.000'
|| (0.9).toFixed(0) !== '1'
|| (1.255).toFixed(2) !== '1.25'
|| (1000000000000000128).toFixed(0) !== '1000000000000000128'
);

var toFixedHelpers = {
base: 1e7,
size: 6,
data: [0, 0, 0, 0, 0, 0],
multiply: function multiply(n, c) {
var i = -1;
var c2 = c;
while (++i < toFixedHelpers.size) {
c2 += n * toFixedHelpers.data[i];
toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
c2 = floor(c2 / toFixedHelpers.base);
}
},
divide: function divide(n) {
var i = toFixedHelpers.size;
var c = 0;
while (--i >= 0) {
c += toFixedHelpers.data[i];
toFixedHelpers.data[i] = floor(c / n);
c = (c % n) * toFixedHelpers.base;
}
},
numToString: function numToString() {
var i = toFixedHelpers.size;
var s = '';
while (--i >= 0) {
if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
var t = $String(toFixedHelpers.data[i]);
if (s === '') {
s = t;
} else {
s += strSlice('0000000', 0, 7 - t.length) + t;
}
}
}
return s;
},
pow: function pow(x, n, acc) {
return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
},
log: function log(x) {
var n = 0;
var x2 = x;
while (x2 >= 4096) {
n += 12;
x2 /= 4096;
}
while (x2 >= 2) {
n += 1;
x2 /= 2;
}
return n;
}
};

var toFixedShim = function toFixed(fractionDigits) {
var f, x, s, m, e, z, j, k;
f = $Number(fractionDigits);
f = isActualNaN(f) ? 0 : floor(f);

if (f < 0 || f > 20) {
throw new RangeError('Number.toFixed called with invalid number of decimals');
}

x = $Number(this);

if (isActualNaN(x)) {
return 'NaN';
}
if (x <= -1e21 || x >= 1e21) {
return $String(x);
}

s = '';

if (x < 0) {
s = '-';
x = -x;
}

m = '0';

if (x > 1e-21) {
e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
z *= 0x10000000000000; // pow(2, 52);
e = 52 - e;
if (e > 0) {
toFixedHelpers.multiply(0, z);
j = f;

while (j >= 7) {
toFixedHelpers.multiply(1e7, 0);
j -= 7;
}

toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
j = e - 1;

while (j >= 23) {
toFixedHelpers.divide(1 << 23);
j -= 23;
}

toFixedHelpers.divide(1 << j);
toFixedHelpers.multiply(1, 1);
toFixedHelpers.divide(2);
m = toFixedHelpers.numToString();
} else {
toFixedHelpers.multiply(0, z);
toFixedHelpers.multiply(1 << (-e), 0);
m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
}
}

if (f > 0) {
k = m.length;

if (k <= f) {
m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
} else {
m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
}
} else {
m = s + m;
}

return m;
};
defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);

var hasToExponentialRoundingBug = (function () {
try {
return (-6.9e-11).toExponential(4) !== '-6.9000e-11';
} catch (e) {
return false;
}
}());
var toExponentialAllowsInfiniteDigits = (function () {
try {
(1).toExponential(Infinity);
(1).toExponential(-Infinity);
return true;
} catch (e) {
return false;
}
}());
var originalToExponential = call.bind(NumberPrototype.toExponential);
var numberToString = call.bind(NumberPrototype.toString);
var numberValueOf = call.bind(NumberPrototype.valueOf);
defineProperties(NumberPrototype, {
toExponential: function toExponential(fractionDigits) {
var x = numberValueOf(this);

if (typeof fractionDigits === 'undefined') {
return originalToExponential(x);
}
var f = ES.ToInteger(fractionDigits);
if (isActualNaN(x)) {
return 'NaN';
}

if (f < 0 || f > 20) {
if (!isFinite(f)) {
throw new RangeError('toExponential() argument must be between 0 and 20');
}
return originalToExponential(x, f);
}


var s = '';
if (x < 0) {
s = '-';
x = -x;
}
if (x === Infinity) {
return s + 'Infinity';
}
if (typeof fractionDigits !== 'undefined' && (f < 0 || f > 20)) {
throw new RangeError('Fraction digits ' + fractionDigits + ' out of range');
}

var m = '';
var e = 0;
var c = '';
var d = '';
if (x === 0) {
e = 0;
f = 0;
m = '0';
} else { // 9: Else, x != 0
var L = log10(x);
e = floor(L); // 10 ** e <= x and x < 10 ** (e+1)
var n = 0;
if (typeof fractionDigits !== 'undefined') { 
var w = pow(10, e - f); // x / 10 ** (f+1) < w and w <= x / 10 ** f
n = round(x / w); // 10 ** f <= n and n < 10 ** (f+1)
if (2 * x >= (((2 * n) + 1) * w)) {
n += 1; // pick larger value
}
if (n >= pow(10, f + 1)) { // 10e-1 = 1e0
n /= 10;
e += 1;
}
} else {
f = 16; // start from Math.ceil(Math.log10(Number.MAX_SAFE_INTEGER)) and loop down
var guess_n = round(pow(10, L - e + f));
var target_f = f;
while (f-- > 0) {
guess_n = round(pow(10, L - e + f));
if (
abs((guess_n * pow(10, e - f)) - x)
<= abs((n * pow(10, e - target_f)) - x)
) {
target_f = f;
n = guess_n;
}
}
}
m = numberToString(n, 10);
if (typeof fractionDigits === 'undefined') {
while (strSlice(m, -1) === '0') {
m = strSlice(m, 0, -1);
d += 1;
}
}
}
if (f !== 0) {
m = strSlice(m, 0, 1) + '.' + strSlice(m, 1);
}
if (e === 0) {
c = '+';
d = '0';
} else { // 12: Else
c = e > 0 ? '+' : '-';
d = numberToString(abs(e), 10);
}
m += 'e' + c + d;
return s + m;
}
}, hasToExponentialRoundingBug || toExponentialAllowsInfiniteDigits);

var hasToPrecisionUndefinedBug = (function () {
try {
return 1.0.toPrecision(undefined) === '1';
} catch (e) {
return true;
}
}());
var originalToPrecision = call.bind(NumberPrototype.toPrecision);
defineProperties(NumberPrototype, {
toPrecision: function toPrecision(precision) {
return typeof precision === 'undefined' ? originalToPrecision(this) : originalToPrecision(this, precision);
}
}, hasToPrecisionUndefinedBug);

if (
'ab'.split(/(?:ab)*/).length !== 2
|| '.'.split(/(.?)(.?)/).length !== 4
|| 'tesst'.split(/(s)*/)[1] === 't'
|| 'test'.split(/(?:)/, -1).length !== 4
|| ''.split(/.?/).length
|| '.'.split(/()()/).length > 1
) {
(function () {
var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
var maxSafe32BitInt = pow(2, 32) - 1;

StringPrototype.split = function split(separator, limit) {
var string = String(this);
if (typeof separator === 'undefined' && limit === 0) {
return [];
}
if (!isRegex(separator)) {
return strSplit(this, separator, limit);
}

var output = [];
var flags = (separator.ignoreCase ? 'i' : '')
+ (separator.multiline ? 'm' : '')
+ (separator.unicode ? 'u' : '') // in ES6
+ (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
lastLastIndex = 0,
separator2, match, lastIndex, lastLength;
var separatorCopy = new RegExp(separator.source, flags + 'g');
if (!compliantExecNpcg) {
separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
}
/* Values for `limit`, per the spec:
* If undefined: 4294967295 // maxSafe32BitInt
* If 0, Infinity, or NaN: 0
* If positive number: limit = floor(limit); if (limit > 4294967295) limit -= 4294967296;
* If negative number: 4294967296 - floor(abs(limit))
* If other: Type-convert, then use the above rules
*/
var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
match = separatorCopy.exec(string);
while (match) {
lastIndex = match.index + match[0].length;
if (lastIndex > lastLastIndex) {
pushCall(output, strSlice(string, lastLastIndex, match.index));
if (!compliantExecNpcg && match.length > 1) {
match[0].replace(separator2, function () {
for (var i = 1; i < arguments.length - 2; i++) {
if (typeof arguments[i] === 'undefined') {
match[i] = void 0;
}
}
});
}
if (match.length > 1 && match.index < string.length) {
array_push.apply(output, arraySlice(match, 1));
}
lastLength = match[0].length;
lastLastIndex = lastIndex;
if (output.length >= splitLimit) {
break;
}
}
if (separatorCopy.lastIndex === match.index) {
separatorCopy.lastIndex++; // Avoid an infinite loop
}
match = separatorCopy.exec(string);
}
if (lastLastIndex === string.length) {
if (lastLength || !separatorCopy.test('')) {
pushCall(output, '');
}
} else {
pushCall(output, strSlice(string, lastLastIndex));
}
return output.length > splitLimit ? arraySlice(output, 0, splitLimit) : output;
};
}());
} else if ('0'.split(void 0, 0).length) {
StringPrototype.split = function split(separator, limit) {
if (typeof separator === 'undefined' && limit === 0) {
return [];
}
return strSplit(this, separator, limit);
};
}

var str_replace = StringPrototype.replace;
var replaceReportsGroupsCorrectly = (function () {
var groups = [];
'x'.replace(/x(.)?/g, function (match, group) {
pushCall(groups, group);
});
return groups.length === 1 && typeof groups[0] === 'undefined';
}());

if (!replaceReportsGroupsCorrectly) {
StringPrototype.replace = function replace(searchValue, replaceValue) {
var isFn = isCallable(replaceValue);
var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
if (!isFn || !hasCapturingGroups) {
return str_replace.call(this, searchValue, replaceValue);
}
var wrappedReplaceValue = function (match) {
var length = arguments.length;
var originalLastIndex = searchValue.lastIndex;
searchValue.lastIndex = 0; 
var args = searchValue.exec(match) || [];
searchValue.lastIndex = originalLastIndex; 
pushCall(args, arguments[length - 2], arguments[length - 1]);
return replaceValue.apply(this, args);
};
return str_replace.call(this, searchValue, wrappedReplaceValue);

};
}
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
var string_substr = hasNegativeSubstrBug && call.bind(StringPrototype.substr);
defineProperties(StringPrototype, {
substr: function substr(start, length) {
var normalizedStart = start;
if (start < 0) {
normalizedStart = max(this.length + start, 0);
}
return string_substr(this, normalizedStart, length);
}
}, hasNegativeSubstrBug);
var mvs = '\u180E';
var mvsIsWS = (/\s/).test(mvs);
var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'
.replace(/\S/g, ''); // remove the mongolian vowel separator (\u180E) in modern engines
var zeroWidth = '\u200b';
var wsRegexChars = '[' + ws + ']';
var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
var hasTrimWhitespaceBug = StringPrototype.trim && (
ws.trim() !== '' // if ws is not considered whitespace
|| zeroWidth.trim() === '' // if zero-width IS considered whitespace
|| mvs.trim() !== (mvsIsWS ? '' : mvs) // if MVS is either wrongly considered whitespace, or, wrongly considered NOT whitespace
);
defineProperties(StringPrototype, {
trim: function trim() {
'use strict';

if (typeof this === 'undefined' || this === null) {
throw new TypeError("can't convert " + this + ' to object');
}
return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
}
}, hasTrimWhitespaceBug);
var trim = call.bind(String.prototype.trim);

var hasLastIndexBug = StringPrototype.lastIndexOf && 'abc����'.lastIndexOf('����', 2) !== -1;
defineProperties(StringPrototype, {
lastIndexOf: function lastIndexOf(searchString) {
if (typeof this === 'undefined' || this === null) {
throw new TypeError("can't convert " + this + ' to object');
}
var S = $String(this);
var searchStr = $String(searchString);
var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
var start = min(max(pos, 0), S.length);
var searchLen = searchStr.length;
var k = start + searchLen;
while (k > 0) {
k = max(0, k - searchLen);
var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
if (index !== -1) {
return k + index;
}
}
return -1;
}
}, hasLastIndexBug);

var originalLastIndexOf = StringPrototype.lastIndexOf;
defineProperties(StringPrototype, {
lastIndexOf: function lastIndexOf(searchString) {
return originalLastIndexOf.apply(this, arguments);
}
}, StringPrototype.lastIndexOf.length !== 1);

var hexRegex = /^[-+]?0[xX]/;
if (
parseInt(ws + '08') !== 8 
|| parseInt(ws + '0x16') !== 22 
|| (mvsIsWS ? parseInt(mvs + 1) !== 1 : !isNaN(parseInt(mvs + 1))) 
) {
parseInt = (function (origParseInt) {
return function parseInt(str, radix) {
if (this instanceof parseInt) { new origParseInt(); } 
var string = trim(String(str));
var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
return origParseInt(string, defaultedRadix);
};
}(parseInt));
}
var parseIntFailsToThrowOnBoxedSymbols = (function () {
if (typeof Symbol !== 'function') {
return false;
}
try {
parseInt(Object(Symbol.iterator));
return true;
} catch (e) { /**/ }

try {
parseInt(Symbol.iterator);
return true;
} catch (e) { /**/ }

return false;
}());
if (parseIntFailsToThrowOnBoxedSymbols) {
var symbolValueOf = Symbol.prototype.valueOf;
parseInt = (function (origParseInt) {
return function parseInt(str, radix) {
if (this instanceof parseInt) { new origParseInt(); } 
var isSym = typeof str === 'symbol';
if (!isSym && str && typeof str === 'object') {
try {
symbolValueOf.call(str);
isSym = true;
} catch (e) { /**/ }
}
if (isSym) {
'' + str; // jscs:ignore disallowImplicitTypeConversion
}
var string = trim(String(str));
var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
return origParseInt(string, defaultedRadix);
};
}(parseInt));
}
if (1 / parseFloat('-0') !== -Infinity) {
parseFloat = (function (origParseFloat) {
return function parseFloat(string) {
var inputString = trim(String(string));
var result = origParseFloat(inputString);
return result === 0 && strSlice(inputString, 0, 1) === '-' ? -0 : result;
};
}(parseFloat));
}

if (String(new RangeError('test')) !== 'RangeError: test') {
var errorToStringShim = function toString() {
if (typeof this === 'undefined' || this === null) {
throw new TypeError("can't convert " + this + ' to object');
}
var name = this.name;
if (typeof name === 'undefined') {
name = 'Error';
} else if (typeof name !== 'string') {
name = $String(name);
}
var msg = this.message;
if (typeof msg === 'undefined') {
msg = '';
} else if (typeof msg !== 'string') {
msg = $String(msg);
}
if (!name) {
return msg;
}
if (!msg) {
return name;
}
return name + ': ' + msg;
};
Error.prototype.toString = errorToStringShim;
}

if (supportsDescriptors) {
var ensureNonEnumerable = function (obj, prop) {
if (isEnum(obj, prop)) {
var desc = Object.getOwnPropertyDescriptor(obj, prop);
if (desc.configurable) {
desc.enumerable = false;
Object.defineProperty(obj, prop, desc);
}
}
};
ensureNonEnumerable(Error.prototype, 'message');
if (Error.prototype.message !== '') {
Error.prototype.message = '';
}
ensureNonEnumerable(Error.prototype, 'name');
}

if (String(/a/mig) !== '/a/gim') {
var regexToString = function toString() {
var str = '/' + this.source + '/';
if (this.global) {
str += 'g';
}
if (this.ignoreCase) {
str += 'i';
}
if (this.multiline) {
str += 'm';
}
return str;
};
RegExp.prototype.toString = regexToString;
}
}));

(function (root, factory) {
'use strict';
if (typeof define === 'function' && define.amd) {
define(factory);
} else if (typeof exports === 'object') {
module.exports = factory();
} else {
root.returnExports = factory(); 
}
}(this, function () {

var call = Function.call;
var prototypeOfObject = Object.prototype;
var owns = call.bind(prototypeOfObject.hasOwnProperty);
var isEnumerable = call.bind(prototypeOfObject.propertyIsEnumerable);
var toStr = call.bind(prototypeOfObject.toString);
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
if (supportsAccessors) {
defineGetter = call.bind(prototypeOfObject.__defineGetter__);
defineSetter = call.bind(prototypeOfObject.__defineSetter__);
lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
}

var isPrimitive = function isPrimitive(o) {
return o == null || (typeof o !== 'object' && typeof o !== 'function');
};
if (!Object.getPrototypeOf) {
Object.getPrototypeOf = function getPrototypeOf(object) {
var proto = object.__proto__;
if (proto || proto == null) { // `undefined` is for pre-proto browsers
return proto;
} else if (toStr(object.constructor) === '[object Function]') {
return object.constructor.prototype;
} else if (object instanceof Object) {
return prototypeOfObject;
}
return null;

};
}
if (Object.defineProperty) {
var doesGetOwnPropertyDescriptorWork = function doesGetOwnPropertyDescriptorWork(object) {
try {
object.sentinel = 0; 
return Object.getOwnPropertyDescriptor(object, 'sentinel').value === 0;
} catch (exception) {
return false;
}
};
var getOwnPropertyDescriptorWorksOnObject = doesGetOwnPropertyDescriptorWork({});
var getOwnPropertyDescriptorWorksOnDom = typeof document === 'undefined'
|| doesGetOwnPropertyDescriptorWork(document.createElement('div'));
if (!getOwnPropertyDescriptorWorksOnDom || !getOwnPropertyDescriptorWorksOnObject) {
var getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;
}
}

if (!Object.getOwnPropertyDescriptor || getOwnPropertyDescriptorFallback) {
var ERR_NON_OBJECT = 'Object.getOwnPropertyDescriptor called on a non-object: ';
Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
if (isPrimitive(object)) {
throw new TypeError(ERR_NON_OBJECT + object);
}
if (getOwnPropertyDescriptorFallback) {
try {
return getOwnPropertyDescriptorFallback.call(Object, object, property);
} catch (exception) {
}
}

var descriptor;
if (!owns(object, property)) {
return descriptor;
}
descriptor = {
enumerable: isEnumerable(object, property),
configurable: true
};
if (supportsAccessors) {
var prototype = object.__proto__;
var notPrototypeOfObject = object !== prototypeOfObject;
if (notPrototypeOfObject) {
object.__proto__ = prototypeOfObject; 
}

var getter = lookupGetter(object, property);
var setter = lookupSetter(object, property);

if (notPrototypeOfObject) {
object.__proto__ = prototype; 
}

if (getter || setter) {
if (getter) {
descriptor.get = getter;
}
if (setter) {
descriptor.set = setter;
}
return descriptor;
}
}
descriptor.value = object[property];
descriptor.writable = true;
return descriptor;
};
}
if (!Object.getOwnPropertyNames) {
Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
return Object.keys(object);
};
}
if (!Object.create) {
var createEmpty;
var supportsProto = !({ __proto__: null } instanceof Object);
var shouldUseActiveX = function shouldUseActiveX() {
if (!document.domain) {
return false;
}

try {
return !!new ActiveXObject('htmlfile');
} catch (exception) {
return false;
}
};
var getEmptyViaActiveX = function getEmptyViaActiveX() {
var empty;
var xDoc;

xDoc = new ActiveXObject('htmlfile');

var script = 'script';
xDoc.write('<' + script + '></' + script + '>');
xDoc.close();

empty = xDoc.parentWindow.Object.prototype;
xDoc = null;

return empty;
};
var getEmptyViaIFrame = function getEmptyViaIFrame() {
var iframe = document.createElement('iframe');
var parent = document.body || document.documentElement;
var empty;

iframe.style.display = 'none';
parent.appendChild(iframe);
iframe.src = 'javascript:';

empty = iframe.contentWindow.Object.prototype;
parent.removeChild(iframe);
iframe = null;

return empty;
};
if (supportsProto || typeof document === 'undefined') {
createEmpty = function () {
return { __proto__: null };
};
} else {
createEmpty = function () {
var empty = shouldUseActiveX() ? getEmptyViaActiveX() : getEmptyViaIFrame();

delete empty.constructor;
delete empty.hasOwnProperty;
delete empty.propertyIsEnumerable;
delete empty.isPrototypeOf;
delete empty.toLocaleString;
delete empty.toString;
delete empty.valueOf;

var Empty = function Empty() {};
Empty.prototype = empty;
createEmpty = function () {
return new Empty();
};
return new Empty();
};
}

Object.create = function create(prototype, properties) {

var object;
var Type = function Type() {}; // An empty constructor.

if (prototype === null) {
object = createEmpty();
} else if (isPrimitive(prototype)) {
throw new TypeError('Object prototype may only be an Object or null'); // same msg as Chrome
} else {
Type.prototype = prototype;
object = new Type();
object.__proto__ = prototype;
}

if (properties !== void 0) {
Object.defineProperties(object, properties);
}

return object;
};
}

var doesDefinePropertyWork = function doesDefinePropertyWork(object) {
try {
Object.defineProperty(object, 'sentinel', {});
return 'sentinel' in object;
} catch (exception) {
return false;
}
};
if (Object.defineProperty) {
var definePropertyWorksOnObject = doesDefinePropertyWork({});
var definePropertyWorksOnDom = typeof document === 'undefined'
|| doesDefinePropertyWork(document.createElement('div'));
if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
var definePropertyFallback = Object.defineProperty,
definePropertiesFallback = Object.defineProperties;
}
}

if (!Object.defineProperty || definePropertyFallback) {
var ERR_NON_OBJECT_DESCRIPTOR = 'Property description must be an object: ';
var ERR_NON_OBJECT_TARGET = 'Object.defineProperty called on non-object: ';
var ERR_ACCESSORS_NOT_SUPPORTED = 'getters & setters can not be defined on this javascript engine';

Object.defineProperty = function defineProperty(object, property, descriptor) {
if (isPrimitive(object)) {
throw new TypeError(ERR_NON_OBJECT_TARGET + object);
}
if (isPrimitive(descriptor)) {
throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
}
if (definePropertyFallback) {
try {
return definePropertyFallback.call(Object, object, property, descriptor);
} catch (exception) {
}
}
if ('value' in descriptor) {
/*
if ( 
('writable' in descriptor && !descriptor.writable) ||
('enumerable' in descriptor && !descriptor.enumerable) ||
('configurable' in descriptor && !descriptor.configurable)
))
throw new RangeError(
'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
);
*/

if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
var prototype = object.__proto__;
object.__proto__ = prototypeOfObject;
delete object[property];
object[property] = descriptor.value;
object.__proto__ = prototype;
} else {
object[property] = descriptor.value; 
}
} else {
var hasGetter = 'get' in descriptor;
var hasSetter = 'set' in descriptor;
if (!supportsAccessors && (hasGetter || hasSetter)) {
throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
}
if (hasGetter) {
defineGetter(object, property, descriptor.get);
}
if (hasSetter) {
defineSetter(object, property, descriptor.set);
}
}
return object;
};
}
if (!Object.defineProperties || definePropertiesFallback) {
Object.defineProperties = function defineProperties(object, properties) {
if (definePropertiesFallback) {
try {
return definePropertiesFallback.call(Object, object, properties);
} catch (exception) {
}
}

Object.keys(properties).forEach(function (property) {
if (property !== '__proto__') {
Object.defineProperty(object, property, properties[property]);
}
});
return object;
};
}
if (!Object.seal) {
Object.seal = function seal(object) {
if (Object(object) !== object) {
throw new TypeError('Object.seal can only be called on Objects.');
}
return object;
};
}
if (!Object.freeze) {
Object.freeze = function freeze(object) {
if (Object(object) !== object) {
throw new TypeError('Object.freeze can only be called on Objects.');
}
return object;
};
}
try {
Object.freeze(function () {});
} catch (exception) {
Object.freeze = (function (freezeObject) {
return function freeze(object) {
if (typeof object === 'function') {
return object;
}
return freezeObject(object);

};
}(Object.freeze));
}
if (!Object.preventExtensions) {
Object.preventExtensions = function preventExtensions(object) {
if (Object(object) !== object) {
throw new TypeError('Object.preventExtensions can only be called on Objects.');
}
return object;
};
}
if (!Object.isSealed) {
Object.isSealed = function isSealed(object) {
if (Object(object) !== object) {
throw new TypeError('Object.isSealed can only be called on Objects.');
}
return false;
};
}
if (!Object.isFrozen) {
Object.isFrozen = function isFrozen(object) {
if (Object(object) !== object) {
throw new TypeError('Object.isFrozen can only be called on Objects.');
}
return false;
};
}
if (!Object.isExtensible) {
Object.isExtensible = function isExtensible(object) {
if (Object(object) !== object) {
throw new TypeError('Object.isExtensible can only be called on Objects.');
}
var name = '';
while (owns(object, name)) {
name += '?';
}
object[name] = true; 
var returnValue = owns(object, name);
delete object[name]; 
return returnValue;
};
}

}));
**********/

end

/**intellisense()
web.script.es5 = es5-shim + es5-sham 补丁，兼容 XP 系统。 \n在创建 web.script 对象以前导入才会生效
end intellisense**/